//////////////////////////////////////////////////////
// Copyright (C) Microsoft. 2018. All rights reserved.
//////////////////////////////////////////////////////


// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!
#pragma once

#include "CoreMinimal.h"
#include "PlayFabCppBaseModel.h"

namespace PlayFab
{
namespace MultiplayerModels
{

    struct PLAYFABCPP_API FAssetReference : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The asset's file name. This is a filename with the .zip, .tar, or .tar.gz extension.
        FString FileName;

        // [optional] The asset's mount path.
        FString MountPath;

        FAssetReference() :
            FPlayFabCppBaseModel(),
            FileName(),
            MountPath()
            {}

        FAssetReference(const FAssetReference& src) :
            FPlayFabCppBaseModel(),
            FileName(src.FileName),
            MountPath(src.MountPath)
            {}

        FAssetReference(const TSharedPtr<FJsonObject>& obj) : FAssetReference()
        {
            readFromValue(obj);
        }

        ~FAssetReference();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAssetReferenceParams : public PlayFab::FPlayFabCppBaseModel
    {
        // The asset's file name. This must be a filename with the .zip, .tar, or .tar.gz extension.
        FString FileName;

        // The asset's mount path.
        FString MountPath;

        FAssetReferenceParams() :
            FPlayFabCppBaseModel(),
            FileName(),
            MountPath()
            {}

        FAssetReferenceParams(const FAssetReferenceParams& src) :
            FPlayFabCppBaseModel(),
            FileName(src.FileName),
            MountPath(src.MountPath)
            {}

        FAssetReferenceParams(const TSharedPtr<FJsonObject>& obj) : FAssetReferenceParams()
        {
            readFromValue(obj);
        }

        ~FAssetReferenceParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAssetSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The asset's file name. This is a filename with the .zip, .tar, or .tar.gz extension.
        FString FileName;

        // [optional] The metadata associated with the asset.
        TMap<FString, FString> Metadata;
        FAssetSummary() :
            FPlayFabCppBaseModel(),
            FileName(),
            Metadata()
            {}

        FAssetSummary(const FAssetSummary& src) :
            FPlayFabCppBaseModel(),
            FileName(src.FileName),
            Metadata(src.Metadata)
            {}

        FAssetSummary(const TSharedPtr<FJsonObject>& obj) : FAssetSummary()
        {
            readFromValue(obj);
        }

        ~FAssetSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum AzureRegion
    {
        AzureRegionAustraliaEast,
        AzureRegionAustraliaSoutheast,
        AzureRegionBrazilSouth,
        AzureRegionCentralUs,
        AzureRegionEastAsia,
        AzureRegionEastUs,
        AzureRegionEastUs2,
        AzureRegionJapanEast,
        AzureRegionJapanWest,
        AzureRegionNorthCentralUs,
        AzureRegionNorthEurope,
        AzureRegionSouthCentralUs,
        AzureRegionSoutheastAsia,
        AzureRegionWestEurope,
        AzureRegionWestUs
    };

    PLAYFABCPP_API void writeAzureRegionEnumJSON(AzureRegion enumVal, JsonWriter& writer);
    PLAYFABCPP_API AzureRegion readAzureRegionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API AzureRegion readAzureRegionFromValue(const FString& value);

    enum AzureVmSize
    {
        AzureVmSizeStandard_D1_v2,
        AzureVmSizeStandard_D2_v2,
        AzureVmSizeStandard_D3_v2,
        AzureVmSizeStandard_D4_v2,
        AzureVmSizeStandard_D5_v2,
        AzureVmSizeStandard_A1_v2,
        AzureVmSizeStandard_A2_v2,
        AzureVmSizeStandard_A4_v2,
        AzureVmSizeStandard_A8_v2,
        AzureVmSizeStandard_A1,
        AzureVmSizeStandard_A2,
        AzureVmSizeStandard_A3,
        AzureVmSizeStandard_A4
    };

    PLAYFABCPP_API void writeAzureVmSizeEnumJSON(AzureVmSize enumVal, JsonWriter& writer);
    PLAYFABCPP_API AzureVmSize readAzureVmSizeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API AzureVmSize readAzureVmSizeFromValue(const FString& value);

    struct PLAYFABCPP_API FBuildRegion : public PlayFab::FPlayFabCppBaseModel
    {
        // The maximum number of multiplayer servers for the region.
        int32 MaxServers;

        // [optional] The build region.
        Boxed<AzureRegion> Region;

        // The number of standby multiplayer servers for the region.
        int32 StandbyServers;

        // [optional] The status of multiplayer servers in the build region.
        FString Status;

        FBuildRegion() :
            FPlayFabCppBaseModel(),
            MaxServers(0),
            Region(),
            StandbyServers(0),
            Status()
            {}

        FBuildRegion(const FBuildRegion& src) :
            FPlayFabCppBaseModel(),
            MaxServers(src.MaxServers),
            Region(src.Region),
            StandbyServers(src.StandbyServers),
            Status(src.Status)
            {}

        FBuildRegion(const TSharedPtr<FJsonObject>& obj) : FBuildRegion()
        {
            readFromValue(obj);
        }

        ~FBuildRegion();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FBuildRegionParams : public PlayFab::FPlayFabCppBaseModel
    {
        // The maximum number of multiplayer servers for the region.
        int32 MaxServers;

        // The build region.
        AzureRegion Region;

        // The number of standby multiplayer servers for the region.
        int32 StandbyServers;

        FBuildRegionParams() :
            FPlayFabCppBaseModel(),
            MaxServers(0),
            Region(),
            StandbyServers(0)
            {}

        FBuildRegionParams(const FBuildRegionParams& src) :
            FPlayFabCppBaseModel(),
            MaxServers(src.MaxServers),
            Region(src.Region),
            StandbyServers(src.StandbyServers)
            {}

        FBuildRegionParams(const TSharedPtr<FJsonObject>& obj) : FBuildRegionParams()
        {
            readFromValue(obj);
        }

        ~FBuildRegionParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FBuildSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The guid string build ID of the build.
        FString BuildId;

        // [optional] The build name.
        FString BuildName;

        // [optional] The time the build was created in UTC.
        Boxed<FDateTime> CreationTime;

        // [optional] The metadata of the build.
        TMap<FString, FString> Metadata;
        FBuildSummary() :
            FPlayFabCppBaseModel(),
            BuildId(),
            BuildName(),
            CreationTime(),
            Metadata()
            {}

        FBuildSummary(const FBuildSummary& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            BuildName(src.BuildName),
            CreationTime(src.CreationTime),
            Metadata(src.Metadata)
            {}

        FBuildSummary(const TSharedPtr<FJsonObject>& obj) : FBuildSummary()
        {
            readFromValue(obj);
        }

        ~FBuildSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCertificate : public PlayFab::FPlayFabCppBaseModel
    {
        // Base64 encoded string contents of the certificate.
        FString Base64EncodedValue;

        // A name for the certificate. This is used to reference certificates in build configurations.
        FString Name;

        /**
         * [optional] If required for your PFX certificate, use this field to provide a password that will be used to install the certificate
         * on the container.
         */
        FString Password;

        FCertificate() :
            FPlayFabCppBaseModel(),
            Base64EncodedValue(),
            Name(),
            Password()
            {}

        FCertificate(const FCertificate& src) :
            FPlayFabCppBaseModel(),
            Base64EncodedValue(src.Base64EncodedValue),
            Name(src.Name),
            Password(src.Password)
            {}

        FCertificate(const TSharedPtr<FJsonObject>& obj) : FCertificate()
        {
            readFromValue(obj);
        }

        ~FCertificate();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCertificateSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The name of the certificate.
        FString Name;

        // [optional] The thumbprint for the certificate.
        FString Thumbprint;

        FCertificateSummary() :
            FPlayFabCppBaseModel(),
            Name(),
            Thumbprint()
            {}

        FCertificateSummary(const FCertificateSummary& src) :
            FPlayFabCppBaseModel(),
            Name(src.Name),
            Thumbprint(src.Thumbprint)
            {}

        FCertificateSummary(const TSharedPtr<FJsonObject>& obj) : FCertificateSummary()
        {
            readFromValue(obj);
        }

        ~FCertificateSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FConnectedPlayer : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The player ID of the player connected to the multiplayer server.
        FString PlayerId;

        FConnectedPlayer() :
            FPlayFabCppBaseModel(),
            PlayerId()
            {}

        FConnectedPlayer(const FConnectedPlayer& src) :
            FPlayFabCppBaseModel(),
            PlayerId(src.PlayerId)
            {}

        FConnectedPlayer(const TSharedPtr<FJsonObject>& obj) : FConnectedPlayer()
        {
            readFromValue(obj);
        }

        ~FConnectedPlayer();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ContainerFlavor
    {
        ContainerFlavorManagedWindowsServerCore,
        ContainerFlavorCustomLinux,
        ContainerFlavorManagedWindowsServerCorePreview
    };

    PLAYFABCPP_API void writeContainerFlavorEnumJSON(ContainerFlavor enumVal, JsonWriter& writer);
    PLAYFABCPP_API ContainerFlavor readContainerFlavorFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API ContainerFlavor readContainerFlavorFromValue(const FString& value);

    struct PLAYFABCPP_API FContainerImageReference : public PlayFab::FPlayFabCppBaseModel
    {
        // The container image name.
        FString ImageName;

        // [optional] The container tag.
        FString Tag;

        FContainerImageReference() :
            FPlayFabCppBaseModel(),
            ImageName(),
            Tag()
            {}

        FContainerImageReference(const FContainerImageReference& src) :
            FPlayFabCppBaseModel(),
            ImageName(src.ImageName),
            Tag(src.Tag)
            {}

        FContainerImageReference(const TSharedPtr<FJsonObject>& obj) : FContainerImageReference()
        {
            readFromValue(obj);
        }

        ~FContainerImageReference();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGameCertificateReferenceParams : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * An alias for the game certificate. The game server will reference this alias via GSDK config to retrieve the game
         * certificate. This alias is used as an identifier in game server code to allow a new certificate with different Name
         * field to be uploaded without the need to change any game server code to reference the new Name.
         */
        FString GsdkAlias;

        /**
         * The name of the game certificate. This name should match the name of a certificate that was previously uploaded to this
         * title.
         */
        FString Name;

        FGameCertificateReferenceParams() :
            FPlayFabCppBaseModel(),
            GsdkAlias(),
            Name()
            {}

        FGameCertificateReferenceParams(const FGameCertificateReferenceParams& src) :
            FPlayFabCppBaseModel(),
            GsdkAlias(src.GsdkAlias),
            Name(src.Name)
            {}

        FGameCertificateReferenceParams(const TSharedPtr<FJsonObject>& obj) : FGameCertificateReferenceParams()
        {
            readFromValue(obj);
        }

        ~FGameCertificateReferenceParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ProtocolType
    {
        ProtocolTypeTCP,
        ProtocolTypeUDP
    };

    PLAYFABCPP_API void writeProtocolTypeEnumJSON(ProtocolType enumVal, JsonWriter& writer);
    PLAYFABCPP_API ProtocolType readProtocolTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API ProtocolType readProtocolTypeFromValue(const FString& value);

    struct PLAYFABCPP_API FPort : public PlayFab::FPlayFabCppBaseModel
    {
        // The name for the port.
        FString Name;

        // The number for the port.
        int32 Num;

        // The protocol for the port.
        ProtocolType Protocol;

        FPort() :
            FPlayFabCppBaseModel(),
            Name(),
            Num(0),
            Protocol()
            {}

        FPort(const FPort& src) :
            FPlayFabCppBaseModel(),
            Name(src.Name),
            Num(src.Num),
            Protocol(src.Protocol)
            {}

        FPort(const TSharedPtr<FJsonObject>& obj) : FPort()
        {
            readFromValue(obj);
        }

        ~FPort();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateBuildWithCustomContainerRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The build name.
        FString BuildName;

        // [optional] The flavor of container to create a build from.
        Boxed<ContainerFlavor> pfContainerFlavor;

        // The name of the container repository.
        FString ContainerRepositoryName;

        // [optional] The container command to run when the multiplayer server has been allocated, including any arguments.
        FString ContainerRunCommand;

        // [optional] The tag for the container.
        FString ContainerTag;

        // [optional] The list of game assets related to the build.
        TArray<FAssetReferenceParams> GameAssetReferences;
        // [optional] The game certificates for the build.
        TArray<FGameCertificateReferenceParams> GameCertificateReferences;
        // [optional] Metadata to tag the build.
        TMap<FString, FString> Metadata;
        // The number of multiplayer servers to host on a single VM.
        int32 MultiplayerServerCountPerVm;

        // The ports to map the build on.
        TArray<FPort> Ports;
        // The region configurations for the build.
        TArray<FBuildRegionParams> RegionConfigurations;
        // [optional] The VM size to create the build on.
        Boxed<AzureVmSize> VmSize;

        FCreateBuildWithCustomContainerRequest() :
            FPlayFabCppBaseModel(),
            BuildName(),
            pfContainerFlavor(),
            ContainerRepositoryName(),
            ContainerRunCommand(),
            ContainerTag(),
            GameAssetReferences(),
            GameCertificateReferences(),
            Metadata(),
            MultiplayerServerCountPerVm(0),
            Ports(),
            RegionConfigurations(),
            VmSize()
            {}

        FCreateBuildWithCustomContainerRequest(const FCreateBuildWithCustomContainerRequest& src) :
            FPlayFabCppBaseModel(),
            BuildName(src.BuildName),
            pfContainerFlavor(src.pfContainerFlavor),
            ContainerRepositoryName(src.ContainerRepositoryName),
            ContainerRunCommand(src.ContainerRunCommand),
            ContainerTag(src.ContainerTag),
            GameAssetReferences(src.GameAssetReferences),
            GameCertificateReferences(src.GameCertificateReferences),
            Metadata(src.Metadata),
            MultiplayerServerCountPerVm(src.MultiplayerServerCountPerVm),
            Ports(src.Ports),
            RegionConfigurations(src.RegionConfigurations),
            VmSize(src.VmSize)
            {}

        FCreateBuildWithCustomContainerRequest(const TSharedPtr<FJsonObject>& obj) : FCreateBuildWithCustomContainerRequest()
        {
            readFromValue(obj);
        }

        ~FCreateBuildWithCustomContainerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGameCertificateReference : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * [optional] An alias for the game certificate. The game server will reference this alias via GSDK config to retrieve the game
         * certificate. This alias is used as an identifier in game server code to allow a new certificate with different Name
         * field to be uploaded without the need to change any game server code to reference the new Name.
         */
        FString GsdkAlias;

        /**
         * [optional] The name of the game certificate. This name should match the name of a certificate that was previously uploaded to this
         * title.
         */
        FString Name;

        FGameCertificateReference() :
            FPlayFabCppBaseModel(),
            GsdkAlias(),
            Name()
            {}

        FGameCertificateReference(const FGameCertificateReference& src) :
            FPlayFabCppBaseModel(),
            GsdkAlias(src.GsdkAlias),
            Name(src.Name)
            {}

        FGameCertificateReference(const TSharedPtr<FJsonObject>& obj) : FGameCertificateReference()
        {
            readFromValue(obj);
        }

        ~FGameCertificateReference();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateBuildWithCustomContainerResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The guid string build ID. Must be unique for every build.
        FString BuildId;

        // [optional] The build name.
        FString BuildName;

        // [optional] The flavor of container of the build.
        Boxed<ContainerFlavor> pfContainerFlavor;

        // [optional] The container command to run when the multiplayer server has been allocated, including any arguments.
        FString ContainerRunCommand;

        // [optional] The time the build was created in UTC.
        Boxed<FDateTime> CreationTime;

        // [optional] The custom game container image reference information.
        TSharedPtr<FContainerImageReference> CustomGameContainerImage;

        // [optional] The game assets for the build.
        TArray<FAssetReference> GameAssetReferences;
        // [optional] The game certificates for the build.
        TArray<FGameCertificateReference> GameCertificateReferences;
        // [optional] The metadata of the build.
        TMap<FString, FString> Metadata;
        // The number of multiplayer servers to host on a single VM of the build.
        int32 MultiplayerServerCountPerVm;

        // [optional] The ports the build is mapped on.
        TArray<FPort> Ports;
        // [optional] The region configuration for the build.
        TArray<FBuildRegion> RegionConfigurations;
        // [optional] The VM size the build was created on.
        Boxed<AzureVmSize> VmSize;

        FCreateBuildWithCustomContainerResponse() :
            FPlayFabCppBaseModel(),
            BuildId(),
            BuildName(),
            pfContainerFlavor(),
            ContainerRunCommand(),
            CreationTime(),
            CustomGameContainerImage(nullptr),
            GameAssetReferences(),
            GameCertificateReferences(),
            Metadata(),
            MultiplayerServerCountPerVm(0),
            Ports(),
            RegionConfigurations(),
            VmSize()
            {}

        FCreateBuildWithCustomContainerResponse(const FCreateBuildWithCustomContainerResponse& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            BuildName(src.BuildName),
            pfContainerFlavor(src.pfContainerFlavor),
            ContainerRunCommand(src.ContainerRunCommand),
            CreationTime(src.CreationTime),
            CustomGameContainerImage(src.CustomGameContainerImage.IsValid() ? MakeShareable(new FContainerImageReference(*src.CustomGameContainerImage)) : nullptr),
            GameAssetReferences(src.GameAssetReferences),
            GameCertificateReferences(src.GameCertificateReferences),
            Metadata(src.Metadata),
            MultiplayerServerCountPerVm(src.MultiplayerServerCountPerVm),
            Ports(src.Ports),
            RegionConfigurations(src.RegionConfigurations),
            VmSize(src.VmSize)
            {}

        FCreateBuildWithCustomContainerResponse(const TSharedPtr<FJsonObject>& obj) : FCreateBuildWithCustomContainerResponse()
        {
            readFromValue(obj);
        }

        ~FCreateBuildWithCustomContainerResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateBuildWithManagedContainerRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The build name.
        FString BuildName;

        // [optional] The flavor of container to create a build from.
        Boxed<ContainerFlavor> pfContainerFlavor;

        // The list of game assets related to the build.
        TArray<FAssetReferenceParams> GameAssetReferences;
        // [optional] The game certificates for the build.
        TArray<FGameCertificateReferenceParams> GameCertificateReferences;
        // [optional] Metadata to tag the build.
        TMap<FString, FString> Metadata;
        // The number of multiplayer servers to host on a single VM.
        int32 MultiplayerServerCountPerVm;

        // The ports to map the build on.
        TArray<FPort> Ports;
        // The region configurations for the build.
        TArray<FBuildRegionParams> RegionConfigurations;
        // The command to run when the multiplayer server is started, including any arguments.
        FString StartMultiplayerServerCommand;

        // [optional] The VM size to create the build on.
        Boxed<AzureVmSize> VmSize;

        FCreateBuildWithManagedContainerRequest() :
            FPlayFabCppBaseModel(),
            BuildName(),
            pfContainerFlavor(),
            GameAssetReferences(),
            GameCertificateReferences(),
            Metadata(),
            MultiplayerServerCountPerVm(0),
            Ports(),
            RegionConfigurations(),
            StartMultiplayerServerCommand(),
            VmSize()
            {}

        FCreateBuildWithManagedContainerRequest(const FCreateBuildWithManagedContainerRequest& src) :
            FPlayFabCppBaseModel(),
            BuildName(src.BuildName),
            pfContainerFlavor(src.pfContainerFlavor),
            GameAssetReferences(src.GameAssetReferences),
            GameCertificateReferences(src.GameCertificateReferences),
            Metadata(src.Metadata),
            MultiplayerServerCountPerVm(src.MultiplayerServerCountPerVm),
            Ports(src.Ports),
            RegionConfigurations(src.RegionConfigurations),
            StartMultiplayerServerCommand(src.StartMultiplayerServerCommand),
            VmSize(src.VmSize)
            {}

        FCreateBuildWithManagedContainerRequest(const TSharedPtr<FJsonObject>& obj) : FCreateBuildWithManagedContainerRequest()
        {
            readFromValue(obj);
        }

        ~FCreateBuildWithManagedContainerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateBuildWithManagedContainerResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The guid string build ID. Must be unique for every build.
        FString BuildId;

        // [optional] The build name.
        FString BuildName;

        // [optional] The flavor of container of the build.
        Boxed<ContainerFlavor> pfContainerFlavor;

        // [optional] The time the build was created in UTC.
        Boxed<FDateTime> CreationTime;

        // [optional] The game assets for the build.
        TArray<FAssetReference> GameAssetReferences;
        // [optional] The game certificates for the build.
        TArray<FGameCertificateReference> GameCertificateReferences;
        // [optional] The metadata of the build.
        TMap<FString, FString> Metadata;
        // The number of multiplayer servers to host on a single VM of the build.
        int32 MultiplayerServerCountPerVm;

        // [optional] The ports the build is mapped on.
        TArray<FPort> Ports;
        // [optional] The region configuration for the build.
        TArray<FBuildRegion> RegionConfigurations;
        // [optional] The command to run when the multiplayer server has been allocated, including any arguments.
        FString StartMultiplayerServerCommand;

        // [optional] The VM size the build was created on.
        Boxed<AzureVmSize> VmSize;

        FCreateBuildWithManagedContainerResponse() :
            FPlayFabCppBaseModel(),
            BuildId(),
            BuildName(),
            pfContainerFlavor(),
            CreationTime(),
            GameAssetReferences(),
            GameCertificateReferences(),
            Metadata(),
            MultiplayerServerCountPerVm(0),
            Ports(),
            RegionConfigurations(),
            StartMultiplayerServerCommand(),
            VmSize()
            {}

        FCreateBuildWithManagedContainerResponse(const FCreateBuildWithManagedContainerResponse& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            BuildName(src.BuildName),
            pfContainerFlavor(src.pfContainerFlavor),
            CreationTime(src.CreationTime),
            GameAssetReferences(src.GameAssetReferences),
            GameCertificateReferences(src.GameCertificateReferences),
            Metadata(src.Metadata),
            MultiplayerServerCountPerVm(src.MultiplayerServerCountPerVm),
            Ports(src.Ports),
            RegionConfigurations(src.RegionConfigurations),
            StartMultiplayerServerCommand(src.StartMultiplayerServerCommand),
            VmSize(src.VmSize)
            {}

        FCreateBuildWithManagedContainerResponse(const TSharedPtr<FJsonObject>& obj) : FCreateBuildWithManagedContainerResponse()
        {
            readFromValue(obj);
        }

        ~FCreateBuildWithManagedContainerResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateRemoteUserRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The guid string build ID of to create the remote user for.
        FString BuildId;

        // [optional] The expiration time for the remote user created. Defaults to expiring in one day if not specified.
        Boxed<FDateTime> ExpirationTime;

        // The region of virtual machine to create the remote user for.
        AzureRegion Region;

        // The username to create the remote user with.
        FString Username;

        // The virtual machine ID the multiplayer server is located on.
        FString VmId;

        FCreateRemoteUserRequest() :
            FPlayFabCppBaseModel(),
            BuildId(),
            ExpirationTime(),
            Region(),
            Username(),
            VmId()
            {}

        FCreateRemoteUserRequest(const FCreateRemoteUserRequest& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            ExpirationTime(src.ExpirationTime),
            Region(src.Region),
            Username(src.Username),
            VmId(src.VmId)
            {}

        FCreateRemoteUserRequest(const TSharedPtr<FJsonObject>& obj) : FCreateRemoteUserRequest()
        {
            readFromValue(obj);
        }

        ~FCreateRemoteUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateRemoteUserResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The expiration time for the remote user created.
        Boxed<FDateTime> ExpirationTime;

        // [optional] The generated password for the remote user that was created.
        FString Password;

        // [optional] The username for the remote user that was created.
        FString Username;

        FCreateRemoteUserResponse() :
            FPlayFabCppBaseModel(),
            ExpirationTime(),
            Password(),
            Username()
            {}

        FCreateRemoteUserResponse(const FCreateRemoteUserResponse& src) :
            FPlayFabCppBaseModel(),
            ExpirationTime(src.ExpirationTime),
            Password(src.Password),
            Username(src.Username)
            {}

        FCreateRemoteUserResponse(const TSharedPtr<FJsonObject>& obj) : FCreateRemoteUserResponse()
        {
            readFromValue(obj);
        }

        ~FCreateRemoteUserResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteAssetRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The filename of the asset to delete. This must be a filename with the .zip, .tar, or .tar.gz extension.
        FString FileName;

        FDeleteAssetRequest() :
            FPlayFabCppBaseModel(),
            FileName()
            {}

        FDeleteAssetRequest(const FDeleteAssetRequest& src) :
            FPlayFabCppBaseModel(),
            FileName(src.FileName)
            {}

        FDeleteAssetRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteAssetRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteAssetRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteBuildRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The guid string build ID of the build to delete.
        FString BuildId;

        FDeleteBuildRequest() :
            FPlayFabCppBaseModel(),
            BuildId()
            {}

        FDeleteBuildRequest(const FDeleteBuildRequest& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId)
            {}

        FDeleteBuildRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteBuildRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteBuildRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteCertificateRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The name of the certificate.
        FString Name;

        FDeleteCertificateRequest() :
            FPlayFabCppBaseModel(),
            Name()
            {}

        FDeleteCertificateRequest(const FDeleteCertificateRequest& src) :
            FPlayFabCppBaseModel(),
            Name(src.Name)
            {}

        FDeleteCertificateRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteCertificateRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteCertificateRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteRemoteUserRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The guid string build ID of the multiplayer server where the remote user is to delete.
        FString BuildId;

        // The region of the multiplayer server where the remote user is to delete.
        AzureRegion Region;

        // The username of the remote user to delete.
        FString Username;

        // The virtual machine ID the multiplayer server is located on.
        FString VmId;

        FDeleteRemoteUserRequest() :
            FPlayFabCppBaseModel(),
            BuildId(),
            Region(),
            Username(),
            VmId()
            {}

        FDeleteRemoteUserRequest(const FDeleteRemoteUserRequest& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            Region(src.Region),
            Username(src.Username),
            VmId(src.VmId)
            {}

        FDeleteRemoteUserRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteRemoteUserRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteRemoteUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FEmptyResponse : public PlayFab::FPlayFabCppBaseModel
    {
        FEmptyResponse() :
            FPlayFabCppBaseModel()
            {}

        FEmptyResponse(const FEmptyResponse& src) :
            FPlayFabCppBaseModel()
            {}

        FEmptyResponse(const TSharedPtr<FJsonObject>& obj) : FEmptyResponse()
        {
            readFromValue(obj);
        }

        ~FEmptyResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FEnableMultiplayerServersForTitleRequest : public PlayFab::FPlayFabCppBaseModel
    {
        FEnableMultiplayerServersForTitleRequest() :
            FPlayFabCppBaseModel()
            {}

        FEnableMultiplayerServersForTitleRequest(const FEnableMultiplayerServersForTitleRequest& src) :
            FPlayFabCppBaseModel()
            {}

        FEnableMultiplayerServersForTitleRequest(const TSharedPtr<FJsonObject>& obj) : FEnableMultiplayerServersForTitleRequest()
        {
            readFromValue(obj);
        }

        ~FEnableMultiplayerServersForTitleRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum TitleMultiplayerServerEnabledStatus
    {
        TitleMultiplayerServerEnabledStatusInitializing,
        TitleMultiplayerServerEnabledStatusEnabled,
        TitleMultiplayerServerEnabledStatusDisabled
    };

    PLAYFABCPP_API void writeTitleMultiplayerServerEnabledStatusEnumJSON(TitleMultiplayerServerEnabledStatus enumVal, JsonWriter& writer);
    PLAYFABCPP_API TitleMultiplayerServerEnabledStatus readTitleMultiplayerServerEnabledStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API TitleMultiplayerServerEnabledStatus readTitleMultiplayerServerEnabledStatusFromValue(const FString& value);

    struct PLAYFABCPP_API FEnableMultiplayerServersForTitleResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The enabled status for the multiplayer server features for the title.
        Boxed<TitleMultiplayerServerEnabledStatus> Status;

        FEnableMultiplayerServersForTitleResponse() :
            FPlayFabCppBaseModel(),
            Status()
            {}

        FEnableMultiplayerServersForTitleResponse(const FEnableMultiplayerServersForTitleResponse& src) :
            FPlayFabCppBaseModel(),
            Status(src.Status)
            {}

        FEnableMultiplayerServersForTitleResponse(const TSharedPtr<FJsonObject>& obj) : FEnableMultiplayerServersForTitleResponse()
        {
            readFromValue(obj);
        }

        ~FEnableMultiplayerServersForTitleResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetAssetUploadUrlRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The asset's file name to get the upload URL for. This must be a filename with the .zip, .tar, or .tar.gz extension.
        FString FileName;

        FGetAssetUploadUrlRequest() :
            FPlayFabCppBaseModel(),
            FileName()
            {}

        FGetAssetUploadUrlRequest(const FGetAssetUploadUrlRequest& src) :
            FPlayFabCppBaseModel(),
            FileName(src.FileName)
            {}

        FGetAssetUploadUrlRequest(const TSharedPtr<FJsonObject>& obj) : FGetAssetUploadUrlRequest()
        {
            readFromValue(obj);
        }

        ~FGetAssetUploadUrlRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetAssetUploadUrlResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The asset's upload URL.
        FString AssetUploadUrl;

        /**
         * [optional] The asset's file name to get the upload URL for. This must be a filename will be a file with the .zip, .tar, or .tar.gz
         * extension.
         */
        FString FileName;

        FGetAssetUploadUrlResponse() :
            FPlayFabCppBaseModel(),
            AssetUploadUrl(),
            FileName()
            {}

        FGetAssetUploadUrlResponse(const FGetAssetUploadUrlResponse& src) :
            FPlayFabCppBaseModel(),
            AssetUploadUrl(src.AssetUploadUrl),
            FileName(src.FileName)
            {}

        FGetAssetUploadUrlResponse(const TSharedPtr<FJsonObject>& obj) : FGetAssetUploadUrlResponse()
        {
            readFromValue(obj);
        }

        ~FGetAssetUploadUrlResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetBuildRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The guid string build ID of the build to get.
        FString BuildId;

        FGetBuildRequest() :
            FPlayFabCppBaseModel(),
            BuildId()
            {}

        FGetBuildRequest(const FGetBuildRequest& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId)
            {}

        FGetBuildRequest(const TSharedPtr<FJsonObject>& obj) : FGetBuildRequest()
        {
            readFromValue(obj);
        }

        ~FGetBuildRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetBuildResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The guid string build ID of the build.
        FString BuildId;

        // [optional] The build name.
        FString BuildName;

        // [optional] The current build status.
        FString BuildStatus;

        // [optional] The flavor of container of he build.
        Boxed<ContainerFlavor> pfContainerFlavor;

        /**
         * [optional] The container command to run when the multiplayer server has been allocated, including any arguments. This only applies
         * to custom builds. If the build is a managed build, this field will be null.
         */
        FString ContainerRunCommand;

        // [optional] The time the build was created in UTC.
        Boxed<FDateTime> CreationTime;

        // [optional] The custom game container image for a custom build.
        TSharedPtr<FContainerImageReference> CustomGameContainerImage;

        // [optional] The game assets for the build.
        TArray<FAssetReference> GameAssetReferences;
        // [optional] The game certificates for the build.
        TArray<FGameCertificateReference> GameCertificateReferences;
        // [optional] The metadata of the build.
        TMap<FString, FString> Metadata;
        // The number of multiplayer servers to hosted on a single VM of the build.
        int32 MultiplayerServerCountPerVm;

        // [optional] The ports the build is mapped on.
        TArray<FPort> Ports;
        // [optional] The region configuration for the build.
        TArray<FBuildRegion> RegionConfigurations;
        /**
         * [optional] The command to run when the multiplayer server has been allocated, including any arguments. This only applies to managed
         * builds. If the build is a custom build, this field will be null.
         */
        FString StartMultiplayerServerCommand;

        // [optional] The VM size the build was created on.
        Boxed<AzureVmSize> VmSize;

        FGetBuildResponse() :
            FPlayFabCppBaseModel(),
            BuildId(),
            BuildName(),
            BuildStatus(),
            pfContainerFlavor(),
            ContainerRunCommand(),
            CreationTime(),
            CustomGameContainerImage(nullptr),
            GameAssetReferences(),
            GameCertificateReferences(),
            Metadata(),
            MultiplayerServerCountPerVm(0),
            Ports(),
            RegionConfigurations(),
            StartMultiplayerServerCommand(),
            VmSize()
            {}

        FGetBuildResponse(const FGetBuildResponse& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            BuildName(src.BuildName),
            BuildStatus(src.BuildStatus),
            pfContainerFlavor(src.pfContainerFlavor),
            ContainerRunCommand(src.ContainerRunCommand),
            CreationTime(src.CreationTime),
            CustomGameContainerImage(src.CustomGameContainerImage.IsValid() ? MakeShareable(new FContainerImageReference(*src.CustomGameContainerImage)) : nullptr),
            GameAssetReferences(src.GameAssetReferences),
            GameCertificateReferences(src.GameCertificateReferences),
            Metadata(src.Metadata),
            MultiplayerServerCountPerVm(src.MultiplayerServerCountPerVm),
            Ports(src.Ports),
            RegionConfigurations(src.RegionConfigurations),
            StartMultiplayerServerCommand(src.StartMultiplayerServerCommand),
            VmSize(src.VmSize)
            {}

        FGetBuildResponse(const TSharedPtr<FJsonObject>& obj) : FGetBuildResponse()
        {
            readFromValue(obj);
        }

        ~FGetBuildResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetContainerRegistryCredentialsRequest : public PlayFab::FPlayFabCppBaseModel
    {
        FGetContainerRegistryCredentialsRequest() :
            FPlayFabCppBaseModel()
            {}

        FGetContainerRegistryCredentialsRequest(const FGetContainerRegistryCredentialsRequest& src) :
            FPlayFabCppBaseModel()
            {}

        FGetContainerRegistryCredentialsRequest(const TSharedPtr<FJsonObject>& obj) : FGetContainerRegistryCredentialsRequest()
        {
            readFromValue(obj);
        }

        ~FGetContainerRegistryCredentialsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetContainerRegistryCredentialsResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The url of the container registry.
        FString DnsName;

        // [optional] The password for accessing the container registry.
        FString Password;

        // [optional] The username for accessing the container registry.
        FString Username;

        FGetContainerRegistryCredentialsResponse() :
            FPlayFabCppBaseModel(),
            DnsName(),
            Password(),
            Username()
            {}

        FGetContainerRegistryCredentialsResponse(const FGetContainerRegistryCredentialsResponse& src) :
            FPlayFabCppBaseModel(),
            DnsName(src.DnsName),
            Password(src.Password),
            Username(src.Username)
            {}

        FGetContainerRegistryCredentialsResponse(const TSharedPtr<FJsonObject>& obj) : FGetContainerRegistryCredentialsResponse()
        {
            readFromValue(obj);
        }

        ~FGetContainerRegistryCredentialsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMultiplayerServerDetailsRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The guid string build ID of the multiplayer server to get details for.
        FString BuildId;

        // The region the multiplayer server is located in to get details for.
        AzureRegion Region;

        /**
         * The title generated guid string session ID of the multiplayer server to get details for. This is to keep track of
         * multiplayer server sessions.
         */
        FString SessionId;

        FGetMultiplayerServerDetailsRequest() :
            FPlayFabCppBaseModel(),
            BuildId(),
            Region(),
            SessionId()
            {}

        FGetMultiplayerServerDetailsRequest(const FGetMultiplayerServerDetailsRequest& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            Region(src.Region),
            SessionId(src.SessionId)
            {}

        FGetMultiplayerServerDetailsRequest(const TSharedPtr<FJsonObject>& obj) : FGetMultiplayerServerDetailsRequest()
        {
            readFromValue(obj);
        }

        ~FGetMultiplayerServerDetailsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMultiplayerServerDetailsResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The connected players in the multiplayer server.
        TArray<FConnectedPlayer> ConnectedPlayers;
        // [optional] The IPv4 address of the virtual machine that is hosting this multiplayer server.
        FString IPV4Address;

        // [optional] The time (UTC) at which a change in the multiplayer server state was observed.
        Boxed<FDateTime> LastStateTransitionTime;

        // [optional] The ports the multiplayer server uses.
        TArray<FPort> Ports;
        // [optional] The region the multiplayer server is located in.
        Boxed<AzureRegion> Region;

        // [optional] The string server ID of the multiplayer server generated by PlayFab.
        FString ServerId;

        // [optional] The guid string session ID of the multiplayer server.
        FString SessionId;

        // [optional] The state of the multiplayer server.
        FString State;

        // [optional] The virtual machine ID that the multiplayer server is located on.
        FString VmId;

        FGetMultiplayerServerDetailsResponse() :
            FPlayFabCppBaseModel(),
            ConnectedPlayers(),
            IPV4Address(),
            LastStateTransitionTime(),
            Ports(),
            Region(),
            ServerId(),
            SessionId(),
            State(),
            VmId()
            {}

        FGetMultiplayerServerDetailsResponse(const FGetMultiplayerServerDetailsResponse& src) :
            FPlayFabCppBaseModel(),
            ConnectedPlayers(src.ConnectedPlayers),
            IPV4Address(src.IPV4Address),
            LastStateTransitionTime(src.LastStateTransitionTime),
            Ports(src.Ports),
            Region(src.Region),
            ServerId(src.ServerId),
            SessionId(src.SessionId),
            State(src.State),
            VmId(src.VmId)
            {}

        FGetMultiplayerServerDetailsResponse(const TSharedPtr<FJsonObject>& obj) : FGetMultiplayerServerDetailsResponse()
        {
            readFromValue(obj);
        }

        ~FGetMultiplayerServerDetailsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetRemoteLoginEndpointRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The guid string build ID of the multiplayer server to get remote login information for.
        FString BuildId;

        // The region of the multiplayer server to get remote login information for.
        AzureRegion Region;

        // The virtual machine ID the multiplayer server is located on.
        FString VmId;

        FGetRemoteLoginEndpointRequest() :
            FPlayFabCppBaseModel(),
            BuildId(),
            Region(),
            VmId()
            {}

        FGetRemoteLoginEndpointRequest(const FGetRemoteLoginEndpointRequest& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            Region(src.Region),
            VmId(src.VmId)
            {}

        FGetRemoteLoginEndpointRequest(const TSharedPtr<FJsonObject>& obj) : FGetRemoteLoginEndpointRequest()
        {
            readFromValue(obj);
        }

        ~FGetRemoteLoginEndpointRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetRemoteLoginEndpointResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The remote login IPV4 address of multiplayer server.
        FString IPV4Address;

        // The remote login port of multiplayer server.
        int32 Port;

        FGetRemoteLoginEndpointResponse() :
            FPlayFabCppBaseModel(),
            IPV4Address(),
            Port(0)
            {}

        FGetRemoteLoginEndpointResponse(const FGetRemoteLoginEndpointResponse& src) :
            FPlayFabCppBaseModel(),
            IPV4Address(src.IPV4Address),
            Port(src.Port)
            {}

        FGetRemoteLoginEndpointResponse(const TSharedPtr<FJsonObject>& obj) : FGetRemoteLoginEndpointResponse()
        {
            readFromValue(obj);
        }

        ~FGetRemoteLoginEndpointResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTitleEnabledForMultiplayerServersStatusRequest : public PlayFab::FPlayFabCppBaseModel
    {
        FGetTitleEnabledForMultiplayerServersStatusRequest() :
            FPlayFabCppBaseModel()
            {}

        FGetTitleEnabledForMultiplayerServersStatusRequest(const FGetTitleEnabledForMultiplayerServersStatusRequest& src) :
            FPlayFabCppBaseModel()
            {}

        FGetTitleEnabledForMultiplayerServersStatusRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleEnabledForMultiplayerServersStatusRequest()
        {
            readFromValue(obj);
        }

        ~FGetTitleEnabledForMultiplayerServersStatusRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTitleEnabledForMultiplayerServersStatusResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The enabled status for the multiplayer server features for the title.
        Boxed<TitleMultiplayerServerEnabledStatus> Status;

        FGetTitleEnabledForMultiplayerServersStatusResponse() :
            FPlayFabCppBaseModel(),
            Status()
            {}

        FGetTitleEnabledForMultiplayerServersStatusResponse(const FGetTitleEnabledForMultiplayerServersStatusResponse& src) :
            FPlayFabCppBaseModel(),
            Status(src.Status)
            {}

        FGetTitleEnabledForMultiplayerServersStatusResponse(const TSharedPtr<FJsonObject>& obj) : FGetTitleEnabledForMultiplayerServersStatusResponse()
        {
            readFromValue(obj);
        }

        ~FGetTitleEnabledForMultiplayerServersStatusResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListAssetSummariesRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListAssetSummariesRequest() :
            FPlayFabCppBaseModel(),
            PageSize(),
            SkipToken()
            {}

        FListAssetSummariesRequest(const FListAssetSummariesRequest& src) :
            FPlayFabCppBaseModel(),
            PageSize(src.PageSize),
            SkipToken(src.SkipToken)
            {}

        FListAssetSummariesRequest(const TSharedPtr<FJsonObject>& obj) : FListAssetSummariesRequest()
        {
            readFromValue(obj);
        }

        ~FListAssetSummariesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListAssetSummariesResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The list of asset summaries.
        TArray<FAssetSummary> AssetSummaries;
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListAssetSummariesResponse() :
            FPlayFabCppBaseModel(),
            AssetSummaries(),
            PageSize(0),
            SkipToken()
            {}

        FListAssetSummariesResponse(const FListAssetSummariesResponse& src) :
            FPlayFabCppBaseModel(),
            AssetSummaries(src.AssetSummaries),
            PageSize(src.PageSize),
            SkipToken(src.SkipToken)
            {}

        FListAssetSummariesResponse(const TSharedPtr<FJsonObject>& obj) : FListAssetSummariesResponse()
        {
            readFromValue(obj);
        }

        ~FListAssetSummariesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListBuildSummariesRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListBuildSummariesRequest() :
            FPlayFabCppBaseModel(),
            PageSize(),
            SkipToken()
            {}

        FListBuildSummariesRequest(const FListBuildSummariesRequest& src) :
            FPlayFabCppBaseModel(),
            PageSize(src.PageSize),
            SkipToken(src.SkipToken)
            {}

        FListBuildSummariesRequest(const TSharedPtr<FJsonObject>& obj) : FListBuildSummariesRequest()
        {
            readFromValue(obj);
        }

        ~FListBuildSummariesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListBuildSummariesResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The list of build summaries for a title.
        TArray<FBuildSummary> BuildSummaries;
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListBuildSummariesResponse() :
            FPlayFabCppBaseModel(),
            BuildSummaries(),
            PageSize(0),
            SkipToken()
            {}

        FListBuildSummariesResponse(const FListBuildSummariesResponse& src) :
            FPlayFabCppBaseModel(),
            BuildSummaries(src.BuildSummaries),
            PageSize(src.PageSize),
            SkipToken(src.SkipToken)
            {}

        FListBuildSummariesResponse(const TSharedPtr<FJsonObject>& obj) : FListBuildSummariesResponse()
        {
            readFromValue(obj);
        }

        ~FListBuildSummariesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListCertificateSummariesRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListCertificateSummariesRequest() :
            FPlayFabCppBaseModel(),
            PageSize(),
            SkipToken()
            {}

        FListCertificateSummariesRequest(const FListCertificateSummariesRequest& src) :
            FPlayFabCppBaseModel(),
            PageSize(src.PageSize),
            SkipToken(src.SkipToken)
            {}

        FListCertificateSummariesRequest(const TSharedPtr<FJsonObject>& obj) : FListCertificateSummariesRequest()
        {
            readFromValue(obj);
        }

        ~FListCertificateSummariesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListCertificateSummariesResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The list of game certificates.
        TArray<FCertificateSummary> CertificateSummaries;
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListCertificateSummariesResponse() :
            FPlayFabCppBaseModel(),
            CertificateSummaries(),
            PageSize(0),
            SkipToken()
            {}

        FListCertificateSummariesResponse(const FListCertificateSummariesResponse& src) :
            FPlayFabCppBaseModel(),
            CertificateSummaries(src.CertificateSummaries),
            PageSize(src.PageSize),
            SkipToken(src.SkipToken)
            {}

        FListCertificateSummariesResponse(const TSharedPtr<FJsonObject>& obj) : FListCertificateSummariesResponse()
        {
            readFromValue(obj);
        }

        ~FListCertificateSummariesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListContainerImagesRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListContainerImagesRequest() :
            FPlayFabCppBaseModel(),
            PageSize(),
            SkipToken()
            {}

        FListContainerImagesRequest(const FListContainerImagesRequest& src) :
            FPlayFabCppBaseModel(),
            PageSize(src.PageSize),
            SkipToken(src.SkipToken)
            {}

        FListContainerImagesRequest(const TSharedPtr<FJsonObject>& obj) : FListContainerImagesRequest()
        {
            readFromValue(obj);
        }

        ~FListContainerImagesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListContainerImagesResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The list of container images.
        TArray<FString> Images;
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListContainerImagesResponse() :
            FPlayFabCppBaseModel(),
            Images(),
            PageSize(0),
            SkipToken()
            {}

        FListContainerImagesResponse(const FListContainerImagesResponse& src) :
            FPlayFabCppBaseModel(),
            Images(src.Images),
            PageSize(src.PageSize),
            SkipToken(src.SkipToken)
            {}

        FListContainerImagesResponse(const TSharedPtr<FJsonObject>& obj) : FListContainerImagesResponse()
        {
            readFromValue(obj);
        }

        ~FListContainerImagesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListContainerImageTagsRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The container images we want to list tags for.
        FString ImageName;

        FListContainerImageTagsRequest() :
            FPlayFabCppBaseModel(),
            ImageName()
            {}

        FListContainerImageTagsRequest(const FListContainerImageTagsRequest& src) :
            FPlayFabCppBaseModel(),
            ImageName(src.ImageName)
            {}

        FListContainerImageTagsRequest(const TSharedPtr<FJsonObject>& obj) : FListContainerImageTagsRequest()
        {
            readFromValue(obj);
        }

        ~FListContainerImageTagsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListContainerImageTagsResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The list of tags for a particular container image.
        TArray<FString> Tags;
        FListContainerImageTagsResponse() :
            FPlayFabCppBaseModel(),
            Tags()
            {}

        FListContainerImageTagsResponse(const FListContainerImageTagsResponse& src) :
            FPlayFabCppBaseModel(),
            Tags(src.Tags)
            {}

        FListContainerImageTagsResponse(const TSharedPtr<FJsonObject>& obj) : FListContainerImageTagsResponse()
        {
            readFromValue(obj);
        }

        ~FListContainerImageTagsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListMultiplayerServersRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The guid string build ID of the multiplayer servers to list.
        FString BuildId;

        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // The region the multiplayer servers to list.
        AzureRegion Region;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListMultiplayerServersRequest() :
            FPlayFabCppBaseModel(),
            BuildId(),
            PageSize(),
            Region(),
            SkipToken()
            {}

        FListMultiplayerServersRequest(const FListMultiplayerServersRequest& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            PageSize(src.PageSize),
            Region(src.Region),
            SkipToken(src.SkipToken)
            {}

        FListMultiplayerServersRequest(const TSharedPtr<FJsonObject>& obj) : FListMultiplayerServersRequest()
        {
            readFromValue(obj);
        }

        ~FListMultiplayerServersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FMultiplayerServerSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The connected players in the multiplayer server.
        TArray<FConnectedPlayer> ConnectedPlayers;
        // [optional] The time (UTC) at which a change in the multiplayer server state was observed.
        Boxed<FDateTime> LastStateTransitionTime;

        // [optional] The region the multiplayer server is located in.
        Boxed<AzureRegion> Region;

        // [optional] The string server ID of the multiplayer server generated by PlayFab.
        FString ServerId;

        // [optional] The state of the multiplayer server.
        FString State;

        // [optional] The virtual machine ID that the multiplayer server is located on.
        FString VmId;

        FMultiplayerServerSummary() :
            FPlayFabCppBaseModel(),
            ConnectedPlayers(),
            LastStateTransitionTime(),
            Region(),
            ServerId(),
            State(),
            VmId()
            {}

        FMultiplayerServerSummary(const FMultiplayerServerSummary& src) :
            FPlayFabCppBaseModel(),
            ConnectedPlayers(src.ConnectedPlayers),
            LastStateTransitionTime(src.LastStateTransitionTime),
            Region(src.Region),
            ServerId(src.ServerId),
            State(src.State),
            VmId(src.VmId)
            {}

        FMultiplayerServerSummary(const TSharedPtr<FJsonObject>& obj) : FMultiplayerServerSummary()
        {
            readFromValue(obj);
        }

        ~FMultiplayerServerSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListMultiplayerServersResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The list of multiplayer server summary details.
        TArray<FMultiplayerServerSummary> MultiplayerServerSummaries;
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListMultiplayerServersResponse() :
            FPlayFabCppBaseModel(),
            MultiplayerServerSummaries(),
            PageSize(0),
            SkipToken()
            {}

        FListMultiplayerServersResponse(const FListMultiplayerServersResponse& src) :
            FPlayFabCppBaseModel(),
            MultiplayerServerSummaries(src.MultiplayerServerSummaries),
            PageSize(src.PageSize),
            SkipToken(src.SkipToken)
            {}

        FListMultiplayerServersResponse(const TSharedPtr<FJsonObject>& obj) : FListMultiplayerServersResponse()
        {
            readFromValue(obj);
        }

        ~FListMultiplayerServersResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListQosServersRequest : public PlayFab::FPlayFabCppBaseModel
    {
        FListQosServersRequest() :
            FPlayFabCppBaseModel()
            {}

        FListQosServersRequest(const FListQosServersRequest& src) :
            FPlayFabCppBaseModel()
            {}

        FListQosServersRequest(const TSharedPtr<FJsonObject>& obj) : FListQosServersRequest()
        {
            readFromValue(obj);
        }

        ~FListQosServersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FQosServer : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The region the QoS server is located in.
        Boxed<AzureRegion> Region;

        // [optional] The QoS server URL.
        FString ServerUrl;

        FQosServer() :
            FPlayFabCppBaseModel(),
            Region(),
            ServerUrl()
            {}

        FQosServer(const FQosServer& src) :
            FPlayFabCppBaseModel(),
            Region(src.Region),
            ServerUrl(src.ServerUrl)
            {}

        FQosServer(const TSharedPtr<FJsonObject>& obj) : FQosServer()
        {
            readFromValue(obj);
        }

        ~FQosServer();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListQosServersResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // The page size on the response.
        int32 PageSize;

        // [optional] The list of QoS servers.
        TArray<FQosServer> QosServers;
        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListQosServersResponse() :
            FPlayFabCppBaseModel(),
            PageSize(0),
            QosServers(),
            SkipToken()
            {}

        FListQosServersResponse(const FListQosServersResponse& src) :
            FPlayFabCppBaseModel(),
            PageSize(src.PageSize),
            QosServers(src.QosServers),
            SkipToken(src.SkipToken)
            {}

        FListQosServersResponse(const TSharedPtr<FJsonObject>& obj) : FListQosServersResponse()
        {
            readFromValue(obj);
        }

        ~FListQosServersResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListVirtualMachineSummariesRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The guid string build ID of the virtual machines to list.
        FString BuildId;

        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // The region of the virtual machines to list.
        AzureRegion Region;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListVirtualMachineSummariesRequest() :
            FPlayFabCppBaseModel(),
            BuildId(),
            PageSize(),
            Region(),
            SkipToken()
            {}

        FListVirtualMachineSummariesRequest(const FListVirtualMachineSummariesRequest& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            PageSize(src.PageSize),
            Region(src.Region),
            SkipToken(src.SkipToken)
            {}

        FListVirtualMachineSummariesRequest(const TSharedPtr<FJsonObject>& obj) : FListVirtualMachineSummariesRequest()
        {
            readFromValue(obj);
        }

        ~FListVirtualMachineSummariesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FVirtualMachineSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The virtual machine health status.
        FString HealthStatus;

        // [optional] The virtual machine state.
        FString State;

        // [optional] The virtual machine ID.
        FString VmId;

        FVirtualMachineSummary() :
            FPlayFabCppBaseModel(),
            HealthStatus(),
            State(),
            VmId()
            {}

        FVirtualMachineSummary(const FVirtualMachineSummary& src) :
            FPlayFabCppBaseModel(),
            HealthStatus(src.HealthStatus),
            State(src.State),
            VmId(src.VmId)
            {}

        FVirtualMachineSummary(const TSharedPtr<FJsonObject>& obj) : FVirtualMachineSummary()
        {
            readFromValue(obj);
        }

        ~FVirtualMachineSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListVirtualMachineSummariesResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        // [optional] The list of virtual machine summaries.
        TArray<FVirtualMachineSummary> VirtualMachines;
        FListVirtualMachineSummariesResponse() :
            FPlayFabCppBaseModel(),
            PageSize(0),
            SkipToken(),
            VirtualMachines()
            {}

        FListVirtualMachineSummariesResponse(const FListVirtualMachineSummariesResponse& src) :
            FPlayFabCppBaseModel(),
            PageSize(src.PageSize),
            SkipToken(src.SkipToken),
            VirtualMachines(src.VirtualMachines)
            {}

        FListVirtualMachineSummariesResponse(const TSharedPtr<FJsonObject>& obj) : FListVirtualMachineSummariesResponse()
        {
            readFromValue(obj);
        }

        ~FListVirtualMachineSummariesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRequestMultiplayerServerRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The guid string build ID of the multiplayer server to request.
        FString BuildId;

        /**
         * [optional] Initial list of players (potentially matchmade) allowed to connect to the game. The game server can use this list to
         * validate players connecting to it.
         */
        TArray<FString> InitialPlayers;
        // The preferred regions to request a multiplayer server from.
        TArray<AzureRegion> PreferredRegions;
        /**
         * [optional] Data encoded as a string that is passed to the game server when requested. This can be used to share a cryptographic
         * secret for servers to authenticate clients or to communicate information such as game mode or map through the request
         * flow.
         */
        FString SessionCookie;

        // A guid string session ID created track the multiplayer server session over its life.
        FString SessionId;

        FRequestMultiplayerServerRequest() :
            FPlayFabCppBaseModel(),
            BuildId(),
            InitialPlayers(),
            PreferredRegions(),
            SessionCookie(),
            SessionId()
            {}

        FRequestMultiplayerServerRequest(const FRequestMultiplayerServerRequest& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            InitialPlayers(src.InitialPlayers),
            PreferredRegions(src.PreferredRegions),
            SessionCookie(src.SessionCookie),
            SessionId(src.SessionId)
            {}

        FRequestMultiplayerServerRequest(const TSharedPtr<FJsonObject>& obj) : FRequestMultiplayerServerRequest()
        {
            readFromValue(obj);
        }

        ~FRequestMultiplayerServerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRequestMultiplayerServerResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The connected players in the multiplayer server.
        TArray<FConnectedPlayer> ConnectedPlayers;
        // [optional] The IPv4 address of the virtual machine that is hosting this multiplayer server.
        FString IPV4Address;

        // [optional] The time (UTC) at which a change in the multiplayer server state was observed.
        Boxed<FDateTime> LastStateTransitionTime;

        // [optional] The ports the multiplayer server uses.
        TArray<FPort> Ports;
        // [optional] The region the multiplayer server is located in.
        Boxed<AzureRegion> Region;

        // [optional] The string server ID of the multiplayer server generated by PlayFab.
        FString ServerId;

        // [optional] The guid string session ID of the multiplayer server.
        FString SessionId;

        // [optional] The state of the multiplayer server.
        FString State;

        // [optional] The virtual machine ID that the multiplayer server is located on.
        FString VmId;

        FRequestMultiplayerServerResponse() :
            FPlayFabCppBaseModel(),
            ConnectedPlayers(),
            IPV4Address(),
            LastStateTransitionTime(),
            Ports(),
            Region(),
            ServerId(),
            SessionId(),
            State(),
            VmId()
            {}

        FRequestMultiplayerServerResponse(const FRequestMultiplayerServerResponse& src) :
            FPlayFabCppBaseModel(),
            ConnectedPlayers(src.ConnectedPlayers),
            IPV4Address(src.IPV4Address),
            LastStateTransitionTime(src.LastStateTransitionTime),
            Ports(src.Ports),
            Region(src.Region),
            ServerId(src.ServerId),
            SessionId(src.SessionId),
            State(src.State),
            VmId(src.VmId)
            {}

        FRequestMultiplayerServerResponse(const TSharedPtr<FJsonObject>& obj) : FRequestMultiplayerServerResponse()
        {
            readFromValue(obj);
        }

        ~FRequestMultiplayerServerResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRolloverContainerRegistryCredentialsRequest : public PlayFab::FPlayFabCppBaseModel
    {
        FRolloverContainerRegistryCredentialsRequest() :
            FPlayFabCppBaseModel()
            {}

        FRolloverContainerRegistryCredentialsRequest(const FRolloverContainerRegistryCredentialsRequest& src) :
            FPlayFabCppBaseModel()
            {}

        FRolloverContainerRegistryCredentialsRequest(const TSharedPtr<FJsonObject>& obj) : FRolloverContainerRegistryCredentialsRequest()
        {
            readFromValue(obj);
        }

        ~FRolloverContainerRegistryCredentialsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRolloverContainerRegistryCredentialsResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The url of the container registry.
        FString DnsName;

        // [optional] The password for accessing the container registry.
        FString Password;

        // [optional] The username for accessing the container registry.
        FString Username;

        FRolloverContainerRegistryCredentialsResponse() :
            FPlayFabCppBaseModel(),
            DnsName(),
            Password(),
            Username()
            {}

        FRolloverContainerRegistryCredentialsResponse(const FRolloverContainerRegistryCredentialsResponse& src) :
            FPlayFabCppBaseModel(),
            DnsName(src.DnsName),
            Password(src.Password),
            Username(src.Username)
            {}

        FRolloverContainerRegistryCredentialsResponse(const TSharedPtr<FJsonObject>& obj) : FRolloverContainerRegistryCredentialsResponse()
        {
            readFromValue(obj);
        }

        ~FRolloverContainerRegistryCredentialsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FShutdownMultiplayerServerRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The guid string build ID of the multiplayer server to delete.
        FString BuildId;

        // The region of the multiplayer server to shut down.
        AzureRegion Region;

        // A guid string session ID of the multiplayer server to shut down.
        FString SessionId;

        FShutdownMultiplayerServerRequest() :
            FPlayFabCppBaseModel(),
            BuildId(),
            Region(),
            SessionId()
            {}

        FShutdownMultiplayerServerRequest(const FShutdownMultiplayerServerRequest& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            Region(src.Region),
            SessionId(src.SessionId)
            {}

        FShutdownMultiplayerServerRequest(const TSharedPtr<FJsonObject>& obj) : FShutdownMultiplayerServerRequest()
        {
            readFromValue(obj);
        }

        ~FShutdownMultiplayerServerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateBuildRegionsRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The guid string ID of the build we want to update regions for.
        FString BuildId;

        // The updated region configuration that should be applied to the specified build.
        TArray<FBuildRegionParams> BuildRegions;
        FUpdateBuildRegionsRequest() :
            FPlayFabCppBaseModel(),
            BuildId(),
            BuildRegions()
            {}

        FUpdateBuildRegionsRequest(const FUpdateBuildRegionsRequest& src) :
            FPlayFabCppBaseModel(),
            BuildId(src.BuildId),
            BuildRegions(src.BuildRegions)
            {}

        FUpdateBuildRegionsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBuildRegionsRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateBuildRegionsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUploadCertificateRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The game certificate to upload.
        FCertificate GameCertificate;

        FUploadCertificateRequest() :
            FPlayFabCppBaseModel(),
            GameCertificate()
            {}

        FUploadCertificateRequest(const FUploadCertificateRequest& src) :
            FPlayFabCppBaseModel(),
            GameCertificate(src.GameCertificate)
            {}

        FUploadCertificateRequest(const TSharedPtr<FJsonObject>& obj) : FUploadCertificateRequest()
        {
            readFromValue(obj);
        }

        ~FUploadCertificateRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

}
}
