//////////////////////////////////////////////////////
// Copyright (C) Microsoft. 2018. All rights reserved.
//////////////////////////////////////////////////////


// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!

#include "Core/PlayFabMultiplayerDataModels.h"
#include "Core/PlayFabJsonHelpers.h"

using namespace PlayFab;
using namespace PlayFab::MultiplayerModels;

PlayFab::MultiplayerModels::FAssetReference::~FAssetReference()
{

}

void PlayFab::MultiplayerModels::FAssetReference::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (FileName.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("FileName")); writer->WriteValue(FileName); }

    if (MountPath.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("MountPath")); writer->WriteValue(MountPath); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FAssetReference::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> MountPathValue = obj->TryGetField(TEXT("MountPath"));
    if (MountPathValue.IsValid() && !MountPathValue->IsNull())
    {
        FString TmpValue;
        if (MountPathValue->TryGetString(TmpValue)) { MountPath = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FAssetReferenceParams::~FAssetReferenceParams()
{

}

void PlayFab::MultiplayerModels::FAssetReferenceParams::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("FileName")); writer->WriteValue(FileName);

    writer->WriteIdentifierPrefix(TEXT("MountPath")); writer->WriteValue(MountPath);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FAssetReferenceParams::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> MountPathValue = obj->TryGetField(TEXT("MountPath"));
    if (MountPathValue.IsValid() && !MountPathValue->IsNull())
    {
        FString TmpValue;
        if (MountPathValue->TryGetString(TmpValue)) { MountPath = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FAssetSummary::~FAssetSummary()
{

}

void PlayFab::MultiplayerModels::FAssetSummary::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (FileName.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("FileName")); writer->WriteValue(FileName); }

    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FAssetSummary::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

void PlayFab::MultiplayerModels::writeAzureRegionEnumJSON(AzureRegion enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case AzureRegionAustraliaEast: writer->WriteValue(TEXT("AustraliaEast")); break;
    case AzureRegionAustraliaSoutheast: writer->WriteValue(TEXT("AustraliaSoutheast")); break;
    case AzureRegionBrazilSouth: writer->WriteValue(TEXT("BrazilSouth")); break;
    case AzureRegionCentralUs: writer->WriteValue(TEXT("CentralUs")); break;
    case AzureRegionEastAsia: writer->WriteValue(TEXT("EastAsia")); break;
    case AzureRegionEastUs: writer->WriteValue(TEXT("EastUs")); break;
    case AzureRegionEastUs2: writer->WriteValue(TEXT("EastUs2")); break;
    case AzureRegionJapanEast: writer->WriteValue(TEXT("JapanEast")); break;
    case AzureRegionJapanWest: writer->WriteValue(TEXT("JapanWest")); break;
    case AzureRegionNorthCentralUs: writer->WriteValue(TEXT("NorthCentralUs")); break;
    case AzureRegionNorthEurope: writer->WriteValue(TEXT("NorthEurope")); break;
    case AzureRegionSouthCentralUs: writer->WriteValue(TEXT("SouthCentralUs")); break;
    case AzureRegionSoutheastAsia: writer->WriteValue(TEXT("SoutheastAsia")); break;
    case AzureRegionWestEurope: writer->WriteValue(TEXT("WestEurope")); break;
    case AzureRegionWestUs: writer->WriteValue(TEXT("WestUs")); break;
    }
}

MultiplayerModels::AzureRegion PlayFab::MultiplayerModels::readAzureRegionFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readAzureRegionFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::AzureRegion PlayFab::MultiplayerModels::readAzureRegionFromValue(const FString& value)
{
    static TMap<FString, AzureRegion> _AzureRegionMap;
    if (_AzureRegionMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _AzureRegionMap.Add(TEXT("AustraliaEast"), AzureRegionAustraliaEast);
        _AzureRegionMap.Add(TEXT("AustraliaSoutheast"), AzureRegionAustraliaSoutheast);
        _AzureRegionMap.Add(TEXT("BrazilSouth"), AzureRegionBrazilSouth);
        _AzureRegionMap.Add(TEXT("CentralUs"), AzureRegionCentralUs);
        _AzureRegionMap.Add(TEXT("EastAsia"), AzureRegionEastAsia);
        _AzureRegionMap.Add(TEXT("EastUs"), AzureRegionEastUs);
        _AzureRegionMap.Add(TEXT("EastUs2"), AzureRegionEastUs2);
        _AzureRegionMap.Add(TEXT("JapanEast"), AzureRegionJapanEast);
        _AzureRegionMap.Add(TEXT("JapanWest"), AzureRegionJapanWest);
        _AzureRegionMap.Add(TEXT("NorthCentralUs"), AzureRegionNorthCentralUs);
        _AzureRegionMap.Add(TEXT("NorthEurope"), AzureRegionNorthEurope);
        _AzureRegionMap.Add(TEXT("SouthCentralUs"), AzureRegionSouthCentralUs);
        _AzureRegionMap.Add(TEXT("SoutheastAsia"), AzureRegionSoutheastAsia);
        _AzureRegionMap.Add(TEXT("WestEurope"), AzureRegionWestEurope);
        _AzureRegionMap.Add(TEXT("WestUs"), AzureRegionWestUs);

    }

    if (!value.IsEmpty())
    {
        auto output = _AzureRegionMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return AzureRegionAustraliaEast; // Basically critical fail
}

void PlayFab::MultiplayerModels::writeAzureVmSizeEnumJSON(AzureVmSize enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case AzureVmSizeStandard_D1_v2: writer->WriteValue(TEXT("Standard_D1_v2")); break;
    case AzureVmSizeStandard_D2_v2: writer->WriteValue(TEXT("Standard_D2_v2")); break;
    case AzureVmSizeStandard_D3_v2: writer->WriteValue(TEXT("Standard_D3_v2")); break;
    case AzureVmSizeStandard_D4_v2: writer->WriteValue(TEXT("Standard_D4_v2")); break;
    case AzureVmSizeStandard_D5_v2: writer->WriteValue(TEXT("Standard_D5_v2")); break;
    case AzureVmSizeStandard_A1_v2: writer->WriteValue(TEXT("Standard_A1_v2")); break;
    case AzureVmSizeStandard_A2_v2: writer->WriteValue(TEXT("Standard_A2_v2")); break;
    case AzureVmSizeStandard_A4_v2: writer->WriteValue(TEXT("Standard_A4_v2")); break;
    case AzureVmSizeStandard_A8_v2: writer->WriteValue(TEXT("Standard_A8_v2")); break;
    case AzureVmSizeStandard_A1: writer->WriteValue(TEXT("Standard_A1")); break;
    case AzureVmSizeStandard_A2: writer->WriteValue(TEXT("Standard_A2")); break;
    case AzureVmSizeStandard_A3: writer->WriteValue(TEXT("Standard_A3")); break;
    case AzureVmSizeStandard_A4: writer->WriteValue(TEXT("Standard_A4")); break;
    }
}

MultiplayerModels::AzureVmSize PlayFab::MultiplayerModels::readAzureVmSizeFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readAzureVmSizeFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::AzureVmSize PlayFab::MultiplayerModels::readAzureVmSizeFromValue(const FString& value)
{
    static TMap<FString, AzureVmSize> _AzureVmSizeMap;
    if (_AzureVmSizeMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _AzureVmSizeMap.Add(TEXT("Standard_D1_v2"), AzureVmSizeStandard_D1_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_D2_v2"), AzureVmSizeStandard_D2_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_D3_v2"), AzureVmSizeStandard_D3_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_D4_v2"), AzureVmSizeStandard_D4_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_D5_v2"), AzureVmSizeStandard_D5_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_A1_v2"), AzureVmSizeStandard_A1_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_A2_v2"), AzureVmSizeStandard_A2_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_A4_v2"), AzureVmSizeStandard_A4_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_A8_v2"), AzureVmSizeStandard_A8_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_A1"), AzureVmSizeStandard_A1);
        _AzureVmSizeMap.Add(TEXT("Standard_A2"), AzureVmSizeStandard_A2);
        _AzureVmSizeMap.Add(TEXT("Standard_A3"), AzureVmSizeStandard_A3);
        _AzureVmSizeMap.Add(TEXT("Standard_A4"), AzureVmSizeStandard_A4);

    }

    if (!value.IsEmpty())
    {
        auto output = _AzureVmSizeMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return AzureVmSizeStandard_D1_v2; // Basically critical fail
}

PlayFab::MultiplayerModels::FBuildRegion::~FBuildRegion()
{

}

void PlayFab::MultiplayerModels::FBuildRegion::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("MaxServers")); writer->WriteValue(MaxServers);

    if (Region.notNull()) { writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer); }

    writer->WriteIdentifierPrefix(TEXT("StandbyServers")); writer->WriteValue(StandbyServers);

    if (Status.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("Status")); writer->WriteValue(Status); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FBuildRegion::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> MaxServersValue = obj->TryGetField(TEXT("MaxServers"));
    if (MaxServersValue.IsValid() && !MaxServersValue->IsNull())
    {
        int32 TmpValue;
        if (MaxServersValue->TryGetNumber(TmpValue)) { MaxServers = TmpValue; }
    }

    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> StandbyServersValue = obj->TryGetField(TEXT("StandbyServers"));
    if (StandbyServersValue.IsValid() && !StandbyServersValue->IsNull())
    {
        int32 TmpValue;
        if (StandbyServersValue->TryGetNumber(TmpValue)) { StandbyServers = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StatusValue = obj->TryGetField(TEXT("Status"));
    if (StatusValue.IsValid() && !StatusValue->IsNull())
    {
        FString TmpValue;
        if (StatusValue->TryGetString(TmpValue)) { Status = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FBuildRegionParams::~FBuildRegionParams()
{

}

void PlayFab::MultiplayerModels::FBuildRegionParams::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("MaxServers")); writer->WriteValue(MaxServers);

    writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer);

    writer->WriteIdentifierPrefix(TEXT("StandbyServers")); writer->WriteValue(StandbyServers);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FBuildRegionParams::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> MaxServersValue = obj->TryGetField(TEXT("MaxServers"));
    if (MaxServersValue.IsValid() && !MaxServersValue->IsNull())
    {
        int32 TmpValue;
        if (MaxServersValue->TryGetNumber(TmpValue)) { MaxServers = TmpValue; }
    }

    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> StandbyServersValue = obj->TryGetField(TEXT("StandbyServers"));
    if (StandbyServersValue.IsValid() && !StandbyServersValue->IsNull())
    {
        int32 TmpValue;
        if (StandbyServersValue->TryGetNumber(TmpValue)) { StandbyServers = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FBuildSummary::~FBuildSummary()
{

}

void PlayFab::MultiplayerModels::FBuildSummary::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (BuildId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId); }

    if (BuildName.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("BuildName")); writer->WriteValue(BuildName); }

    if (CreationTime.notNull()) { writer->WriteIdentifierPrefix(TEXT("CreationTime")); writeDatetime(CreationTime, writer); }

    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FBuildSummary::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> CreationTimeValue = obj->TryGetField(TEXT("CreationTime"));
    if (CreationTimeValue.IsValid())
        CreationTime = readDatetime(CreationTimeValue);


    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCertificate::~FCertificate()
{

}

void PlayFab::MultiplayerModels::FCertificate::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("Base64EncodedValue")); writer->WriteValue(Base64EncodedValue);

    writer->WriteIdentifierPrefix(TEXT("Name")); writer->WriteValue(Name);

    if (Password.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("Password")); writer->WriteValue(Password); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCertificate::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> Base64EncodedValueValue = obj->TryGetField(TEXT("Base64EncodedValue"));
    if (Base64EncodedValueValue.IsValid() && !Base64EncodedValueValue->IsNull())
    {
        FString TmpValue;
        if (Base64EncodedValueValue->TryGetString(TmpValue)) { Base64EncodedValue = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PasswordValue = obj->TryGetField(TEXT("Password"));
    if (PasswordValue.IsValid() && !PasswordValue->IsNull())
    {
        FString TmpValue;
        if (PasswordValue->TryGetString(TmpValue)) { Password = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCertificateSummary::~FCertificateSummary()
{

}

void PlayFab::MultiplayerModels::FCertificateSummary::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Name.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("Name")); writer->WriteValue(Name); }

    if (Thumbprint.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("Thumbprint")); writer->WriteValue(Thumbprint); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCertificateSummary::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ThumbprintValue = obj->TryGetField(TEXT("Thumbprint"));
    if (ThumbprintValue.IsValid() && !ThumbprintValue->IsNull())
    {
        FString TmpValue;
        if (ThumbprintValue->TryGetString(TmpValue)) { Thumbprint = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FConnectedPlayer::~FConnectedPlayer()
{

}

void PlayFab::MultiplayerModels::FConnectedPlayer::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (PlayerId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("PlayerId")); writer->WriteValue(PlayerId); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FConnectedPlayer::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> PlayerIdValue = obj->TryGetField(TEXT("PlayerId"));
    if (PlayerIdValue.IsValid() && !PlayerIdValue->IsNull())
    {
        FString TmpValue;
        if (PlayerIdValue->TryGetString(TmpValue)) { PlayerId = TmpValue; }
    }

    return HasSucceeded;
}

void PlayFab::MultiplayerModels::writeContainerFlavorEnumJSON(ContainerFlavor enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case ContainerFlavorManagedWindowsServerCore: writer->WriteValue(TEXT("ManagedWindowsServerCore")); break;
    case ContainerFlavorCustomLinux: writer->WriteValue(TEXT("CustomLinux")); break;
    case ContainerFlavorManagedWindowsServerCorePreview: writer->WriteValue(TEXT("ManagedWindowsServerCorePreview")); break;
    }
}

MultiplayerModels::ContainerFlavor PlayFab::MultiplayerModels::readContainerFlavorFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readContainerFlavorFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::ContainerFlavor PlayFab::MultiplayerModels::readContainerFlavorFromValue(const FString& value)
{
    static TMap<FString, ContainerFlavor> _ContainerFlavorMap;
    if (_ContainerFlavorMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _ContainerFlavorMap.Add(TEXT("ManagedWindowsServerCore"), ContainerFlavorManagedWindowsServerCore);
        _ContainerFlavorMap.Add(TEXT("CustomLinux"), ContainerFlavorCustomLinux);
        _ContainerFlavorMap.Add(TEXT("ManagedWindowsServerCorePreview"), ContainerFlavorManagedWindowsServerCorePreview);

    }

    if (!value.IsEmpty())
    {
        auto output = _ContainerFlavorMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return ContainerFlavorManagedWindowsServerCore; // Basically critical fail
}

PlayFab::MultiplayerModels::FContainerImageReference::~FContainerImageReference()
{

}

void PlayFab::MultiplayerModels::FContainerImageReference::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("ImageName")); writer->WriteValue(ImageName);

    if (Tag.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("Tag")); writer->WriteValue(Tag); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FContainerImageReference::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> ImageNameValue = obj->TryGetField(TEXT("ImageName"));
    if (ImageNameValue.IsValid() && !ImageNameValue->IsNull())
    {
        FString TmpValue;
        if (ImageNameValue->TryGetString(TmpValue)) { ImageName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TagValue = obj->TryGetField(TEXT("Tag"));
    if (TagValue.IsValid() && !TagValue->IsNull())
    {
        FString TmpValue;
        if (TagValue->TryGetString(TmpValue)) { Tag = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGameCertificateReferenceParams::~FGameCertificateReferenceParams()
{

}

void PlayFab::MultiplayerModels::FGameCertificateReferenceParams::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("GsdkAlias")); writer->WriteValue(GsdkAlias);

    writer->WriteIdentifierPrefix(TEXT("Name")); writer->WriteValue(Name);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGameCertificateReferenceParams::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> GsdkAliasValue = obj->TryGetField(TEXT("GsdkAlias"));
    if (GsdkAliasValue.IsValid() && !GsdkAliasValue->IsNull())
    {
        FString TmpValue;
        if (GsdkAliasValue->TryGetString(TmpValue)) { GsdkAlias = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

void PlayFab::MultiplayerModels::writeProtocolTypeEnumJSON(ProtocolType enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case ProtocolTypeTCP: writer->WriteValue(TEXT("TCP")); break;
    case ProtocolTypeUDP: writer->WriteValue(TEXT("UDP")); break;
    }
}

MultiplayerModels::ProtocolType PlayFab::MultiplayerModels::readProtocolTypeFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readProtocolTypeFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::ProtocolType PlayFab::MultiplayerModels::readProtocolTypeFromValue(const FString& value)
{
    static TMap<FString, ProtocolType> _ProtocolTypeMap;
    if (_ProtocolTypeMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _ProtocolTypeMap.Add(TEXT("TCP"), ProtocolTypeTCP);
        _ProtocolTypeMap.Add(TEXT("UDP"), ProtocolTypeUDP);

    }

    if (!value.IsEmpty())
    {
        auto output = _ProtocolTypeMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return ProtocolTypeTCP; // Basically critical fail
}

PlayFab::MultiplayerModels::FPort::~FPort()
{

}

void PlayFab::MultiplayerModels::FPort::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("Name")); writer->WriteValue(Name);

    writer->WriteIdentifierPrefix(TEXT("Num")); writer->WriteValue(Num);

    writer->WriteIdentifierPrefix(TEXT("Protocol")); writeProtocolTypeEnumJSON(Protocol, writer);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FPort::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NumValue = obj->TryGetField(TEXT("Num"));
    if (NumValue.IsValid() && !NumValue->IsNull())
    {
        int32 TmpValue;
        if (NumValue->TryGetNumber(TmpValue)) { Num = TmpValue; }
    }

    Protocol = readProtocolTypeFromValue(obj->TryGetField(TEXT("Protocol")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateBuildWithCustomContainerRequest::~FCreateBuildWithCustomContainerRequest()
{

}

void PlayFab::MultiplayerModels::FCreateBuildWithCustomContainerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildName")); writer->WriteValue(BuildName);

    if (pfContainerFlavor.notNull()) { writer->WriteIdentifierPrefix(TEXT("ContainerFlavor")); writeContainerFlavorEnumJSON(pfContainerFlavor, writer); }

    writer->WriteIdentifierPrefix(TEXT("ContainerRepositoryName")); writer->WriteValue(ContainerRepositoryName);

    if (ContainerRunCommand.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("ContainerRunCommand")); writer->WriteValue(ContainerRunCommand); }

    if (ContainerTag.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("ContainerTag")); writer->WriteValue(ContainerTag); }

    if (GameAssetReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameAssetReferences"));
        for (const FAssetReferenceParams& item : GameAssetReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameCertificateReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameCertificateReferences"));
        for (const FGameCertificateReferenceParams& item : GameCertificateReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MultiplayerServerCountPerVm")); writer->WriteValue(MultiplayerServerCountPerVm);

    writer->WriteArrayStart(TEXT("Ports"));
    for (const FPort& item : Ports)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    writer->WriteArrayStart(TEXT("RegionConfigurations"));
    for (const FBuildRegionParams& item : RegionConfigurations)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (VmSize.notNull()) { writer->WriteIdentifierPrefix(TEXT("VmSize")); writeAzureVmSizeEnumJSON(VmSize, writer); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateBuildWithCustomContainerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    pfContainerFlavor = readContainerFlavorFromValue(obj->TryGetField(TEXT("ContainerFlavor")));

    const TSharedPtr<FJsonValue> ContainerRepositoryNameValue = obj->TryGetField(TEXT("ContainerRepositoryName"));
    if (ContainerRepositoryNameValue.IsValid() && !ContainerRepositoryNameValue->IsNull())
    {
        FString TmpValue;
        if (ContainerRepositoryNameValue->TryGetString(TmpValue)) { ContainerRepositoryName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ContainerRunCommandValue = obj->TryGetField(TEXT("ContainerRunCommand"));
    if (ContainerRunCommandValue.IsValid() && !ContainerRunCommandValue->IsNull())
    {
        FString TmpValue;
        if (ContainerRunCommandValue->TryGetString(TmpValue)) { ContainerRunCommand = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ContainerTagValue = obj->TryGetField(TEXT("ContainerTag"));
    if (ContainerTagValue.IsValid() && !ContainerTagValue->IsNull())
    {
        FString TmpValue;
        if (ContainerTagValue->TryGetString(TmpValue)) { ContainerTag = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&GameAssetReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameAssetReferences"));
    for (int32 Idx = 0; Idx < GameAssetReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameAssetReferencesArray[Idx];
        GameAssetReferences.Add(FAssetReferenceParams(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&GameCertificateReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameCertificateReferences"));
    for (int32 Idx = 0; Idx < GameCertificateReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameCertificateReferencesArray[Idx];
        GameCertificateReferences.Add(FGameCertificateReferenceParams(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MultiplayerServerCountPerVmValue = obj->TryGetField(TEXT("MultiplayerServerCountPerVm"));
    if (MultiplayerServerCountPerVmValue.IsValid() && !MultiplayerServerCountPerVmValue->IsNull())
    {
        int32 TmpValue;
        if (MultiplayerServerCountPerVmValue->TryGetNumber(TmpValue)) { MultiplayerServerCountPerVm = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegionParams(CurrentItem->AsObject()));
    }


    VmSize = readAzureVmSizeFromValue(obj->TryGetField(TEXT("VmSize")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGameCertificateReference::~FGameCertificateReference()
{

}

void PlayFab::MultiplayerModels::FGameCertificateReference::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (GsdkAlias.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("GsdkAlias")); writer->WriteValue(GsdkAlias); }

    if (Name.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("Name")); writer->WriteValue(Name); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGameCertificateReference::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> GsdkAliasValue = obj->TryGetField(TEXT("GsdkAlias"));
    if (GsdkAliasValue.IsValid() && !GsdkAliasValue->IsNull())
    {
        FString TmpValue;
        if (GsdkAliasValue->TryGetString(TmpValue)) { GsdkAlias = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateBuildWithCustomContainerResponse::~FCreateBuildWithCustomContainerResponse()
{
    //if (CustomGameContainerImage != nullptr) delete CustomGameContainerImage;

}

void PlayFab::MultiplayerModels::FCreateBuildWithCustomContainerResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (BuildId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId); }

    if (BuildName.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("BuildName")); writer->WriteValue(BuildName); }

    if (pfContainerFlavor.notNull()) { writer->WriteIdentifierPrefix(TEXT("ContainerFlavor")); writeContainerFlavorEnumJSON(pfContainerFlavor, writer); }

    if (ContainerRunCommand.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("ContainerRunCommand")); writer->WriteValue(ContainerRunCommand); }

    if (CreationTime.notNull()) { writer->WriteIdentifierPrefix(TEXT("CreationTime")); writeDatetime(CreationTime, writer); }

    if (CustomGameContainerImage.IsValid()) { writer->WriteIdentifierPrefix(TEXT("CustomGameContainerImage")); CustomGameContainerImage->writeJSON(writer); }

    if (GameAssetReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameAssetReferences"));
        for (const FAssetReference& item : GameAssetReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameCertificateReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameCertificateReferences"));
        for (const FGameCertificateReference& item : GameCertificateReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MultiplayerServerCountPerVm")); writer->WriteValue(MultiplayerServerCountPerVm);

    if (Ports.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Ports"));
        for (const FPort& item : Ports)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (RegionConfigurations.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("RegionConfigurations"));
        for (const FBuildRegion& item : RegionConfigurations)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (VmSize.notNull()) { writer->WriteIdentifierPrefix(TEXT("VmSize")); writeAzureVmSizeEnumJSON(VmSize, writer); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateBuildWithCustomContainerResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    pfContainerFlavor = readContainerFlavorFromValue(obj->TryGetField(TEXT("ContainerFlavor")));

    const TSharedPtr<FJsonValue> ContainerRunCommandValue = obj->TryGetField(TEXT("ContainerRunCommand"));
    if (ContainerRunCommandValue.IsValid() && !ContainerRunCommandValue->IsNull())
    {
        FString TmpValue;
        if (ContainerRunCommandValue->TryGetString(TmpValue)) { ContainerRunCommand = TmpValue; }
    }

    const TSharedPtr<FJsonValue> CreationTimeValue = obj->TryGetField(TEXT("CreationTime"));
    if (CreationTimeValue.IsValid())
        CreationTime = readDatetime(CreationTimeValue);


    const TSharedPtr<FJsonValue> CustomGameContainerImageValue = obj->TryGetField(TEXT("CustomGameContainerImage"));
    if (CustomGameContainerImageValue.IsValid() && !CustomGameContainerImageValue->IsNull())
    {
        CustomGameContainerImage = MakeShareable(new FContainerImageReference(CustomGameContainerImageValue->AsObject()));
    }

    const TArray<TSharedPtr<FJsonValue>>&GameAssetReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameAssetReferences"));
    for (int32 Idx = 0; Idx < GameAssetReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameAssetReferencesArray[Idx];
        GameAssetReferences.Add(FAssetReference(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&GameCertificateReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameCertificateReferences"));
    for (int32 Idx = 0; Idx < GameCertificateReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameCertificateReferencesArray[Idx];
        GameCertificateReferences.Add(FGameCertificateReference(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MultiplayerServerCountPerVmValue = obj->TryGetField(TEXT("MultiplayerServerCountPerVm"));
    if (MultiplayerServerCountPerVmValue.IsValid() && !MultiplayerServerCountPerVmValue->IsNull())
    {
        int32 TmpValue;
        if (MultiplayerServerCountPerVmValue->TryGetNumber(TmpValue)) { MultiplayerServerCountPerVm = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegion(CurrentItem->AsObject()));
    }


    VmSize = readAzureVmSizeFromValue(obj->TryGetField(TEXT("VmSize")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateBuildWithManagedContainerRequest::~FCreateBuildWithManagedContainerRequest()
{

}

void PlayFab::MultiplayerModels::FCreateBuildWithManagedContainerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildName")); writer->WriteValue(BuildName);

    if (pfContainerFlavor.notNull()) { writer->WriteIdentifierPrefix(TEXT("ContainerFlavor")); writeContainerFlavorEnumJSON(pfContainerFlavor, writer); }

    writer->WriteArrayStart(TEXT("GameAssetReferences"));
    for (const FAssetReferenceParams& item : GameAssetReferences)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (GameCertificateReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameCertificateReferences"));
        for (const FGameCertificateReferenceParams& item : GameCertificateReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MultiplayerServerCountPerVm")); writer->WriteValue(MultiplayerServerCountPerVm);

    writer->WriteArrayStart(TEXT("Ports"));
    for (const FPort& item : Ports)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    writer->WriteArrayStart(TEXT("RegionConfigurations"));
    for (const FBuildRegionParams& item : RegionConfigurations)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    writer->WriteIdentifierPrefix(TEXT("StartMultiplayerServerCommand")); writer->WriteValue(StartMultiplayerServerCommand);

    if (VmSize.notNull()) { writer->WriteIdentifierPrefix(TEXT("VmSize")); writeAzureVmSizeEnumJSON(VmSize, writer); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateBuildWithManagedContainerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    pfContainerFlavor = readContainerFlavorFromValue(obj->TryGetField(TEXT("ContainerFlavor")));

    const TArray<TSharedPtr<FJsonValue>>&GameAssetReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameAssetReferences"));
    for (int32 Idx = 0; Idx < GameAssetReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameAssetReferencesArray[Idx];
        GameAssetReferences.Add(FAssetReferenceParams(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&GameCertificateReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameCertificateReferences"));
    for (int32 Idx = 0; Idx < GameCertificateReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameCertificateReferencesArray[Idx];
        GameCertificateReferences.Add(FGameCertificateReferenceParams(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MultiplayerServerCountPerVmValue = obj->TryGetField(TEXT("MultiplayerServerCountPerVm"));
    if (MultiplayerServerCountPerVmValue.IsValid() && !MultiplayerServerCountPerVmValue->IsNull())
    {
        int32 TmpValue;
        if (MultiplayerServerCountPerVmValue->TryGetNumber(TmpValue)) { MultiplayerServerCountPerVm = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegionParams(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> StartMultiplayerServerCommandValue = obj->TryGetField(TEXT("StartMultiplayerServerCommand"));
    if (StartMultiplayerServerCommandValue.IsValid() && !StartMultiplayerServerCommandValue->IsNull())
    {
        FString TmpValue;
        if (StartMultiplayerServerCommandValue->TryGetString(TmpValue)) { StartMultiplayerServerCommand = TmpValue; }
    }

    VmSize = readAzureVmSizeFromValue(obj->TryGetField(TEXT("VmSize")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateBuildWithManagedContainerResponse::~FCreateBuildWithManagedContainerResponse()
{

}

void PlayFab::MultiplayerModels::FCreateBuildWithManagedContainerResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (BuildId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId); }

    if (BuildName.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("BuildName")); writer->WriteValue(BuildName); }

    if (pfContainerFlavor.notNull()) { writer->WriteIdentifierPrefix(TEXT("ContainerFlavor")); writeContainerFlavorEnumJSON(pfContainerFlavor, writer); }

    if (CreationTime.notNull()) { writer->WriteIdentifierPrefix(TEXT("CreationTime")); writeDatetime(CreationTime, writer); }

    if (GameAssetReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameAssetReferences"));
        for (const FAssetReference& item : GameAssetReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameCertificateReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameCertificateReferences"));
        for (const FGameCertificateReference& item : GameCertificateReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MultiplayerServerCountPerVm")); writer->WriteValue(MultiplayerServerCountPerVm);

    if (Ports.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Ports"));
        for (const FPort& item : Ports)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (RegionConfigurations.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("RegionConfigurations"));
        for (const FBuildRegion& item : RegionConfigurations)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (StartMultiplayerServerCommand.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("StartMultiplayerServerCommand")); writer->WriteValue(StartMultiplayerServerCommand); }

    if (VmSize.notNull()) { writer->WriteIdentifierPrefix(TEXT("VmSize")); writeAzureVmSizeEnumJSON(VmSize, writer); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateBuildWithManagedContainerResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    pfContainerFlavor = readContainerFlavorFromValue(obj->TryGetField(TEXT("ContainerFlavor")));

    const TSharedPtr<FJsonValue> CreationTimeValue = obj->TryGetField(TEXT("CreationTime"));
    if (CreationTimeValue.IsValid())
        CreationTime = readDatetime(CreationTimeValue);


    const TArray<TSharedPtr<FJsonValue>>&GameAssetReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameAssetReferences"));
    for (int32 Idx = 0; Idx < GameAssetReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameAssetReferencesArray[Idx];
        GameAssetReferences.Add(FAssetReference(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&GameCertificateReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameCertificateReferences"));
    for (int32 Idx = 0; Idx < GameCertificateReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameCertificateReferencesArray[Idx];
        GameCertificateReferences.Add(FGameCertificateReference(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MultiplayerServerCountPerVmValue = obj->TryGetField(TEXT("MultiplayerServerCountPerVm"));
    if (MultiplayerServerCountPerVmValue.IsValid() && !MultiplayerServerCountPerVmValue->IsNull())
    {
        int32 TmpValue;
        if (MultiplayerServerCountPerVmValue->TryGetNumber(TmpValue)) { MultiplayerServerCountPerVm = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegion(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> StartMultiplayerServerCommandValue = obj->TryGetField(TEXT("StartMultiplayerServerCommand"));
    if (StartMultiplayerServerCommandValue.IsValid() && !StartMultiplayerServerCommandValue->IsNull())
    {
        FString TmpValue;
        if (StartMultiplayerServerCommandValue->TryGetString(TmpValue)) { StartMultiplayerServerCommand = TmpValue; }
    }

    VmSize = readAzureVmSizeFromValue(obj->TryGetField(TEXT("VmSize")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateRemoteUserRequest::~FCreateRemoteUserRequest()
{

}

void PlayFab::MultiplayerModels::FCreateRemoteUserRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId);

    if (ExpirationTime.notNull()) { writer->WriteIdentifierPrefix(TEXT("ExpirationTime")); writeDatetime(ExpirationTime, writer); }

    writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer);

    writer->WriteIdentifierPrefix(TEXT("Username")); writer->WriteValue(Username);

    writer->WriteIdentifierPrefix(TEXT("VmId")); writer->WriteValue(VmId);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateRemoteUserRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ExpirationTimeValue = obj->TryGetField(TEXT("ExpirationTime"));
    if (ExpirationTimeValue.IsValid())
        ExpirationTime = readDatetime(ExpirationTimeValue);


    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> UsernameValue = obj->TryGetField(TEXT("Username"));
    if (UsernameValue.IsValid() && !UsernameValue->IsNull())
    {
        FString TmpValue;
        if (UsernameValue->TryGetString(TmpValue)) { Username = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateRemoteUserResponse::~FCreateRemoteUserResponse()
{

}

void PlayFab::MultiplayerModels::FCreateRemoteUserResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (ExpirationTime.notNull()) { writer->WriteIdentifierPrefix(TEXT("ExpirationTime")); writeDatetime(ExpirationTime, writer); }

    if (Password.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("Password")); writer->WriteValue(Password); }

    if (Username.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("Username")); writer->WriteValue(Username); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateRemoteUserResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> ExpirationTimeValue = obj->TryGetField(TEXT("ExpirationTime"));
    if (ExpirationTimeValue.IsValid())
        ExpirationTime = readDatetime(ExpirationTimeValue);


    const TSharedPtr<FJsonValue> PasswordValue = obj->TryGetField(TEXT("Password"));
    if (PasswordValue.IsValid() && !PasswordValue->IsNull())
    {
        FString TmpValue;
        if (PasswordValue->TryGetString(TmpValue)) { Password = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UsernameValue = obj->TryGetField(TEXT("Username"));
    if (UsernameValue.IsValid() && !UsernameValue->IsNull())
    {
        FString TmpValue;
        if (UsernameValue->TryGetString(TmpValue)) { Username = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDeleteAssetRequest::~FDeleteAssetRequest()
{

}

void PlayFab::MultiplayerModels::FDeleteAssetRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("FileName")); writer->WriteValue(FileName);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDeleteAssetRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDeleteBuildRequest::~FDeleteBuildRequest()
{

}

void PlayFab::MultiplayerModels::FDeleteBuildRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDeleteBuildRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDeleteCertificateRequest::~FDeleteCertificateRequest()
{

}

void PlayFab::MultiplayerModels::FDeleteCertificateRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("Name")); writer->WriteValue(Name);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDeleteCertificateRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDeleteRemoteUserRequest::~FDeleteRemoteUserRequest()
{

}

void PlayFab::MultiplayerModels::FDeleteRemoteUserRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId);

    writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer);

    writer->WriteIdentifierPrefix(TEXT("Username")); writer->WriteValue(Username);

    writer->WriteIdentifierPrefix(TEXT("VmId")); writer->WriteValue(VmId);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDeleteRemoteUserRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> UsernameValue = obj->TryGetField(TEXT("Username"));
    if (UsernameValue.IsValid() && !UsernameValue->IsNull())
    {
        FString TmpValue;
        if (UsernameValue->TryGetString(TmpValue)) { Username = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FEmptyResponse::~FEmptyResponse()
{

}

void PlayFab::MultiplayerModels::FEmptyResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FEmptyResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FEnableMultiplayerServersForTitleRequest::~FEnableMultiplayerServersForTitleRequest()
{

}

void PlayFab::MultiplayerModels::FEnableMultiplayerServersForTitleRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FEnableMultiplayerServersForTitleRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

void PlayFab::MultiplayerModels::writeTitleMultiplayerServerEnabledStatusEnumJSON(TitleMultiplayerServerEnabledStatus enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case TitleMultiplayerServerEnabledStatusInitializing: writer->WriteValue(TEXT("Initializing")); break;
    case TitleMultiplayerServerEnabledStatusEnabled: writer->WriteValue(TEXT("Enabled")); break;
    case TitleMultiplayerServerEnabledStatusDisabled: writer->WriteValue(TEXT("Disabled")); break;
    }
}

MultiplayerModels::TitleMultiplayerServerEnabledStatus PlayFab::MultiplayerModels::readTitleMultiplayerServerEnabledStatusFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readTitleMultiplayerServerEnabledStatusFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::TitleMultiplayerServerEnabledStatus PlayFab::MultiplayerModels::readTitleMultiplayerServerEnabledStatusFromValue(const FString& value)
{
    static TMap<FString, TitleMultiplayerServerEnabledStatus> _TitleMultiplayerServerEnabledStatusMap;
    if (_TitleMultiplayerServerEnabledStatusMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _TitleMultiplayerServerEnabledStatusMap.Add(TEXT("Initializing"), TitleMultiplayerServerEnabledStatusInitializing);
        _TitleMultiplayerServerEnabledStatusMap.Add(TEXT("Enabled"), TitleMultiplayerServerEnabledStatusEnabled);
        _TitleMultiplayerServerEnabledStatusMap.Add(TEXT("Disabled"), TitleMultiplayerServerEnabledStatusDisabled);

    }

    if (!value.IsEmpty())
    {
        auto output = _TitleMultiplayerServerEnabledStatusMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return TitleMultiplayerServerEnabledStatusInitializing; // Basically critical fail
}

PlayFab::MultiplayerModels::FEnableMultiplayerServersForTitleResponse::~FEnableMultiplayerServersForTitleResponse()
{

}

void PlayFab::MultiplayerModels::FEnableMultiplayerServersForTitleResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Status.notNull()) { writer->WriteIdentifierPrefix(TEXT("Status")); writeTitleMultiplayerServerEnabledStatusEnumJSON(Status, writer); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FEnableMultiplayerServersForTitleResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    Status = readTitleMultiplayerServerEnabledStatusFromValue(obj->TryGetField(TEXT("Status")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetAssetUploadUrlRequest::~FGetAssetUploadUrlRequest()
{

}

void PlayFab::MultiplayerModels::FGetAssetUploadUrlRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("FileName")); writer->WriteValue(FileName);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetAssetUploadUrlRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetAssetUploadUrlResponse::~FGetAssetUploadUrlResponse()
{

}

void PlayFab::MultiplayerModels::FGetAssetUploadUrlResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AssetUploadUrl.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("AssetUploadUrl")); writer->WriteValue(AssetUploadUrl); }

    if (FileName.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("FileName")); writer->WriteValue(FileName); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetAssetUploadUrlResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AssetUploadUrlValue = obj->TryGetField(TEXT("AssetUploadUrl"));
    if (AssetUploadUrlValue.IsValid() && !AssetUploadUrlValue->IsNull())
    {
        FString TmpValue;
        if (AssetUploadUrlValue->TryGetString(TmpValue)) { AssetUploadUrl = TmpValue; }
    }

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetBuildRequest::~FGetBuildRequest()
{

}

void PlayFab::MultiplayerModels::FGetBuildRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetBuildRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetBuildResponse::~FGetBuildResponse()
{
    //if (CustomGameContainerImage != nullptr) delete CustomGameContainerImage;

}

void PlayFab::MultiplayerModels::FGetBuildResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (BuildId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId); }

    if (BuildName.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("BuildName")); writer->WriteValue(BuildName); }

    if (BuildStatus.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("BuildStatus")); writer->WriteValue(BuildStatus); }

    if (pfContainerFlavor.notNull()) { writer->WriteIdentifierPrefix(TEXT("ContainerFlavor")); writeContainerFlavorEnumJSON(pfContainerFlavor, writer); }

    if (ContainerRunCommand.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("ContainerRunCommand")); writer->WriteValue(ContainerRunCommand); }

    if (CreationTime.notNull()) { writer->WriteIdentifierPrefix(TEXT("CreationTime")); writeDatetime(CreationTime, writer); }

    if (CustomGameContainerImage.IsValid()) { writer->WriteIdentifierPrefix(TEXT("CustomGameContainerImage")); CustomGameContainerImage->writeJSON(writer); }

    if (GameAssetReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameAssetReferences"));
        for (const FAssetReference& item : GameAssetReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameCertificateReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameCertificateReferences"));
        for (const FGameCertificateReference& item : GameCertificateReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MultiplayerServerCountPerVm")); writer->WriteValue(MultiplayerServerCountPerVm);

    if (Ports.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Ports"));
        for (const FPort& item : Ports)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (RegionConfigurations.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("RegionConfigurations"));
        for (const FBuildRegion& item : RegionConfigurations)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (StartMultiplayerServerCommand.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("StartMultiplayerServerCommand")); writer->WriteValue(StartMultiplayerServerCommand); }

    if (VmSize.notNull()) { writer->WriteIdentifierPrefix(TEXT("VmSize")); writeAzureVmSizeEnumJSON(VmSize, writer); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetBuildResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildStatusValue = obj->TryGetField(TEXT("BuildStatus"));
    if (BuildStatusValue.IsValid() && !BuildStatusValue->IsNull())
    {
        FString TmpValue;
        if (BuildStatusValue->TryGetString(TmpValue)) { BuildStatus = TmpValue; }
    }

    pfContainerFlavor = readContainerFlavorFromValue(obj->TryGetField(TEXT("ContainerFlavor")));

    const TSharedPtr<FJsonValue> ContainerRunCommandValue = obj->TryGetField(TEXT("ContainerRunCommand"));
    if (ContainerRunCommandValue.IsValid() && !ContainerRunCommandValue->IsNull())
    {
        FString TmpValue;
        if (ContainerRunCommandValue->TryGetString(TmpValue)) { ContainerRunCommand = TmpValue; }
    }

    const TSharedPtr<FJsonValue> CreationTimeValue = obj->TryGetField(TEXT("CreationTime"));
    if (CreationTimeValue.IsValid())
        CreationTime = readDatetime(CreationTimeValue);


    const TSharedPtr<FJsonValue> CustomGameContainerImageValue = obj->TryGetField(TEXT("CustomGameContainerImage"));
    if (CustomGameContainerImageValue.IsValid() && !CustomGameContainerImageValue->IsNull())
    {
        CustomGameContainerImage = MakeShareable(new FContainerImageReference(CustomGameContainerImageValue->AsObject()));
    }

    const TArray<TSharedPtr<FJsonValue>>&GameAssetReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameAssetReferences"));
    for (int32 Idx = 0; Idx < GameAssetReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameAssetReferencesArray[Idx];
        GameAssetReferences.Add(FAssetReference(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&GameCertificateReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameCertificateReferences"));
    for (int32 Idx = 0; Idx < GameCertificateReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameCertificateReferencesArray[Idx];
        GameCertificateReferences.Add(FGameCertificateReference(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MultiplayerServerCountPerVmValue = obj->TryGetField(TEXT("MultiplayerServerCountPerVm"));
    if (MultiplayerServerCountPerVmValue.IsValid() && !MultiplayerServerCountPerVmValue->IsNull())
    {
        int32 TmpValue;
        if (MultiplayerServerCountPerVmValue->TryGetNumber(TmpValue)) { MultiplayerServerCountPerVm = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegion(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> StartMultiplayerServerCommandValue = obj->TryGetField(TEXT("StartMultiplayerServerCommand"));
    if (StartMultiplayerServerCommandValue.IsValid() && !StartMultiplayerServerCommandValue->IsNull())
    {
        FString TmpValue;
        if (StartMultiplayerServerCommandValue->TryGetString(TmpValue)) { StartMultiplayerServerCommand = TmpValue; }
    }

    VmSize = readAzureVmSizeFromValue(obj->TryGetField(TEXT("VmSize")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetContainerRegistryCredentialsRequest::~FGetContainerRegistryCredentialsRequest()
{

}

void PlayFab::MultiplayerModels::FGetContainerRegistryCredentialsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetContainerRegistryCredentialsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetContainerRegistryCredentialsResponse::~FGetContainerRegistryCredentialsResponse()
{

}

void PlayFab::MultiplayerModels::FGetContainerRegistryCredentialsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (DnsName.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("DnsName")); writer->WriteValue(DnsName); }

    if (Password.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("Password")); writer->WriteValue(Password); }

    if (Username.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("Username")); writer->WriteValue(Username); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetContainerRegistryCredentialsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> DnsNameValue = obj->TryGetField(TEXT("DnsName"));
    if (DnsNameValue.IsValid() && !DnsNameValue->IsNull())
    {
        FString TmpValue;
        if (DnsNameValue->TryGetString(TmpValue)) { DnsName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PasswordValue = obj->TryGetField(TEXT("Password"));
    if (PasswordValue.IsValid() && !PasswordValue->IsNull())
    {
        FString TmpValue;
        if (PasswordValue->TryGetString(TmpValue)) { Password = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UsernameValue = obj->TryGetField(TEXT("Username"));
    if (UsernameValue.IsValid() && !UsernameValue->IsNull())
    {
        FString TmpValue;
        if (UsernameValue->TryGetString(TmpValue)) { Username = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetMultiplayerServerDetailsRequest::~FGetMultiplayerServerDetailsRequest()
{

}

void PlayFab::MultiplayerModels::FGetMultiplayerServerDetailsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId);

    writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer);

    writer->WriteIdentifierPrefix(TEXT("SessionId")); writer->WriteValue(SessionId);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetMultiplayerServerDetailsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> SessionIdValue = obj->TryGetField(TEXT("SessionId"));
    if (SessionIdValue.IsValid() && !SessionIdValue->IsNull())
    {
        FString TmpValue;
        if (SessionIdValue->TryGetString(TmpValue)) { SessionId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetMultiplayerServerDetailsResponse::~FGetMultiplayerServerDetailsResponse()
{

}

void PlayFab::MultiplayerModels::FGetMultiplayerServerDetailsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (ConnectedPlayers.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("ConnectedPlayers"));
        for (const FConnectedPlayer& item : ConnectedPlayers)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (IPV4Address.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("IPV4Address")); writer->WriteValue(IPV4Address); }

    if (LastStateTransitionTime.notNull()) { writer->WriteIdentifierPrefix(TEXT("LastStateTransitionTime")); writeDatetime(LastStateTransitionTime, writer); }

    if (Ports.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Ports"));
        for (const FPort& item : Ports)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (Region.notNull()) { writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer); }

    if (ServerId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("ServerId")); writer->WriteValue(ServerId); }

    if (SessionId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SessionId")); writer->WriteValue(SessionId); }

    if (State.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("State")); writer->WriteValue(State); }

    if (VmId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("VmId")); writer->WriteValue(VmId); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetMultiplayerServerDetailsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&ConnectedPlayersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("ConnectedPlayers"));
    for (int32 Idx = 0; Idx < ConnectedPlayersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ConnectedPlayersArray[Idx];
        ConnectedPlayers.Add(FConnectedPlayer(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> IPV4AddressValue = obj->TryGetField(TEXT("IPV4Address"));
    if (IPV4AddressValue.IsValid() && !IPV4AddressValue->IsNull())
    {
        FString TmpValue;
        if (IPV4AddressValue->TryGetString(TmpValue)) { IPV4Address = TmpValue; }
    }

    const TSharedPtr<FJsonValue> LastStateTransitionTimeValue = obj->TryGetField(TEXT("LastStateTransitionTime"));
    if (LastStateTransitionTimeValue.IsValid())
        LastStateTransitionTime = readDatetime(LastStateTransitionTimeValue);


    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> ServerIdValue = obj->TryGetField(TEXT("ServerId"));
    if (ServerIdValue.IsValid() && !ServerIdValue->IsNull())
    {
        FString TmpValue;
        if (ServerIdValue->TryGetString(TmpValue)) { ServerId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SessionIdValue = obj->TryGetField(TEXT("SessionId"));
    if (SessionIdValue.IsValid() && !SessionIdValue->IsNull())
    {
        FString TmpValue;
        if (SessionIdValue->TryGetString(TmpValue)) { SessionId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StateValue = obj->TryGetField(TEXT("State"));
    if (StateValue.IsValid() && !StateValue->IsNull())
    {
        FString TmpValue;
        if (StateValue->TryGetString(TmpValue)) { State = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetRemoteLoginEndpointRequest::~FGetRemoteLoginEndpointRequest()
{

}

void PlayFab::MultiplayerModels::FGetRemoteLoginEndpointRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId);

    writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer);

    writer->WriteIdentifierPrefix(TEXT("VmId")); writer->WriteValue(VmId);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetRemoteLoginEndpointRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetRemoteLoginEndpointResponse::~FGetRemoteLoginEndpointResponse()
{

}

void PlayFab::MultiplayerModels::FGetRemoteLoginEndpointResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (IPV4Address.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("IPV4Address")); writer->WriteValue(IPV4Address); }

    writer->WriteIdentifierPrefix(TEXT("Port")); writer->WriteValue(Port);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetRemoteLoginEndpointResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> IPV4AddressValue = obj->TryGetField(TEXT("IPV4Address"));
    if (IPV4AddressValue.IsValid() && !IPV4AddressValue->IsNull())
    {
        FString TmpValue;
        if (IPV4AddressValue->TryGetString(TmpValue)) { IPV4Address = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PortValue = obj->TryGetField(TEXT("Port"));
    if (PortValue.IsValid() && !PortValue->IsNull())
    {
        int32 TmpValue;
        if (PortValue->TryGetNumber(TmpValue)) { Port = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetTitleEnabledForMultiplayerServersStatusRequest::~FGetTitleEnabledForMultiplayerServersStatusRequest()
{

}

void PlayFab::MultiplayerModels::FGetTitleEnabledForMultiplayerServersStatusRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetTitleEnabledForMultiplayerServersStatusRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetTitleEnabledForMultiplayerServersStatusResponse::~FGetTitleEnabledForMultiplayerServersStatusResponse()
{

}

void PlayFab::MultiplayerModels::FGetTitleEnabledForMultiplayerServersStatusResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Status.notNull()) { writer->WriteIdentifierPrefix(TEXT("Status")); writeTitleMultiplayerServerEnabledStatusEnumJSON(Status, writer); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetTitleEnabledForMultiplayerServersStatusResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    Status = readTitleMultiplayerServerEnabledStatusFromValue(obj->TryGetField(TEXT("Status")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListAssetSummariesRequest::~FListAssetSummariesRequest()
{

}

void PlayFab::MultiplayerModels::FListAssetSummariesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (PageSize.notNull()) { writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize); }

    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListAssetSummariesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListAssetSummariesResponse::~FListAssetSummariesResponse()
{

}

void PlayFab::MultiplayerModels::FListAssetSummariesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AssetSummaries.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("AssetSummaries"));
        for (const FAssetSummary& item : AssetSummaries)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListAssetSummariesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&AssetSummariesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("AssetSummaries"));
    for (int32 Idx = 0; Idx < AssetSummariesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = AssetSummariesArray[Idx];
        AssetSummaries.Add(FAssetSummary(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListBuildSummariesRequest::~FListBuildSummariesRequest()
{

}

void PlayFab::MultiplayerModels::FListBuildSummariesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (PageSize.notNull()) { writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize); }

    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListBuildSummariesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListBuildSummariesResponse::~FListBuildSummariesResponse()
{

}

void PlayFab::MultiplayerModels::FListBuildSummariesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (BuildSummaries.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("BuildSummaries"));
        for (const FBuildSummary& item : BuildSummaries)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListBuildSummariesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&BuildSummariesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("BuildSummaries"));
    for (int32 Idx = 0; Idx < BuildSummariesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = BuildSummariesArray[Idx];
        BuildSummaries.Add(FBuildSummary(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListCertificateSummariesRequest::~FListCertificateSummariesRequest()
{

}

void PlayFab::MultiplayerModels::FListCertificateSummariesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (PageSize.notNull()) { writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize); }

    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListCertificateSummariesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListCertificateSummariesResponse::~FListCertificateSummariesResponse()
{

}

void PlayFab::MultiplayerModels::FListCertificateSummariesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CertificateSummaries.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("CertificateSummaries"));
        for (const FCertificateSummary& item : CertificateSummaries)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListCertificateSummariesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&CertificateSummariesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("CertificateSummaries"));
    for (int32 Idx = 0; Idx < CertificateSummariesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = CertificateSummariesArray[Idx];
        CertificateSummaries.Add(FCertificateSummary(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListContainerImagesRequest::~FListContainerImagesRequest()
{

}

void PlayFab::MultiplayerModels::FListContainerImagesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (PageSize.notNull()) { writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize); }

    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListContainerImagesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListContainerImagesResponse::~FListContainerImagesResponse()
{

}

void PlayFab::MultiplayerModels::FListContainerImagesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Images.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Images"));
        for (const FString& item : Images)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListContainerImagesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    obj->TryGetStringArrayField(TEXT("Images"), Images);

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListContainerImageTagsRequest::~FListContainerImageTagsRequest()
{

}

void PlayFab::MultiplayerModels::FListContainerImageTagsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (ImageName.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("ImageName")); writer->WriteValue(ImageName); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListContainerImageTagsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> ImageNameValue = obj->TryGetField(TEXT("ImageName"));
    if (ImageNameValue.IsValid() && !ImageNameValue->IsNull())
    {
        FString TmpValue;
        if (ImageNameValue->TryGetString(TmpValue)) { ImageName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListContainerImageTagsResponse::~FListContainerImageTagsResponse()
{

}

void PlayFab::MultiplayerModels::FListContainerImageTagsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Tags.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Tags"));
        for (const FString& item : Tags)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListContainerImageTagsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    obj->TryGetStringArrayField(TEXT("Tags"), Tags);

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListMultiplayerServersRequest::~FListMultiplayerServersRequest()
{

}

void PlayFab::MultiplayerModels::FListMultiplayerServersRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId);

    if (PageSize.notNull()) { writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize); }

    writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer);

    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListMultiplayerServersRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FMultiplayerServerSummary::~FMultiplayerServerSummary()
{

}

void PlayFab::MultiplayerModels::FMultiplayerServerSummary::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (ConnectedPlayers.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("ConnectedPlayers"));
        for (const FConnectedPlayer& item : ConnectedPlayers)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (LastStateTransitionTime.notNull()) { writer->WriteIdentifierPrefix(TEXT("LastStateTransitionTime")); writeDatetime(LastStateTransitionTime, writer); }

    if (Region.notNull()) { writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer); }

    if (ServerId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("ServerId")); writer->WriteValue(ServerId); }

    if (State.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("State")); writer->WriteValue(State); }

    if (VmId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("VmId")); writer->WriteValue(VmId); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FMultiplayerServerSummary::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&ConnectedPlayersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("ConnectedPlayers"));
    for (int32 Idx = 0; Idx < ConnectedPlayersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ConnectedPlayersArray[Idx];
        ConnectedPlayers.Add(FConnectedPlayer(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> LastStateTransitionTimeValue = obj->TryGetField(TEXT("LastStateTransitionTime"));
    if (LastStateTransitionTimeValue.IsValid())
        LastStateTransitionTime = readDatetime(LastStateTransitionTimeValue);


    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> ServerIdValue = obj->TryGetField(TEXT("ServerId"));
    if (ServerIdValue.IsValid() && !ServerIdValue->IsNull())
    {
        FString TmpValue;
        if (ServerIdValue->TryGetString(TmpValue)) { ServerId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StateValue = obj->TryGetField(TEXT("State"));
    if (StateValue.IsValid() && !StateValue->IsNull())
    {
        FString TmpValue;
        if (StateValue->TryGetString(TmpValue)) { State = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListMultiplayerServersResponse::~FListMultiplayerServersResponse()
{

}

void PlayFab::MultiplayerModels::FListMultiplayerServersResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (MultiplayerServerSummaries.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("MultiplayerServerSummaries"));
        for (const FMultiplayerServerSummary& item : MultiplayerServerSummaries)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListMultiplayerServersResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&MultiplayerServerSummariesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("MultiplayerServerSummaries"));
    for (int32 Idx = 0; Idx < MultiplayerServerSummariesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = MultiplayerServerSummariesArray[Idx];
        MultiplayerServerSummaries.Add(FMultiplayerServerSummary(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListQosServersRequest::~FListQosServersRequest()
{

}

void PlayFab::MultiplayerModels::FListQosServersRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListQosServersRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FQosServer::~FQosServer()
{

}

void PlayFab::MultiplayerModels::FQosServer::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Region.notNull()) { writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer); }

    if (ServerUrl.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("ServerUrl")); writer->WriteValue(ServerUrl); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FQosServer::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> ServerUrlValue = obj->TryGetField(TEXT("ServerUrl"));
    if (ServerUrlValue.IsValid() && !ServerUrlValue->IsNull())
    {
        FString TmpValue;
        if (ServerUrlValue->TryGetString(TmpValue)) { ServerUrl = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListQosServersResponse::~FListQosServersResponse()
{

}

void PlayFab::MultiplayerModels::FListQosServersResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize);

    if (QosServers.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("QosServers"));
        for (const FQosServer& item : QosServers)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListQosServersResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&QosServersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("QosServers"));
    for (int32 Idx = 0; Idx < QosServersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = QosServersArray[Idx];
        QosServers.Add(FQosServer(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListVirtualMachineSummariesRequest::~FListVirtualMachineSummariesRequest()
{

}

void PlayFab::MultiplayerModels::FListVirtualMachineSummariesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId);

    if (PageSize.notNull()) { writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize); }

    writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer);

    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListVirtualMachineSummariesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FVirtualMachineSummary::~FVirtualMachineSummary()
{

}

void PlayFab::MultiplayerModels::FVirtualMachineSummary::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (HealthStatus.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("HealthStatus")); writer->WriteValue(HealthStatus); }

    if (State.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("State")); writer->WriteValue(State); }

    if (VmId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("VmId")); writer->WriteValue(VmId); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FVirtualMachineSummary::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> HealthStatusValue = obj->TryGetField(TEXT("HealthStatus"));
    if (HealthStatusValue.IsValid() && !HealthStatusValue->IsNull())
    {
        FString TmpValue;
        if (HealthStatusValue->TryGetString(TmpValue)) { HealthStatus = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StateValue = obj->TryGetField(TEXT("State"));
    if (StateValue.IsValid() && !StateValue->IsNull())
    {
        FString TmpValue;
        if (StateValue->TryGetString(TmpValue)) { State = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListVirtualMachineSummariesResponse::~FListVirtualMachineSummariesResponse()
{

}

void PlayFab::MultiplayerModels::FListVirtualMachineSummariesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("PageSize")); writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SkipToken")); writer->WriteValue(SkipToken); }

    if (VirtualMachines.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("VirtualMachines"));
        for (const FVirtualMachineSummary& item : VirtualMachines)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListVirtualMachineSummariesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&VirtualMachinesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("VirtualMachines"));
    for (int32 Idx = 0; Idx < VirtualMachinesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = VirtualMachinesArray[Idx];
        VirtualMachines.Add(FVirtualMachineSummary(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

PlayFab::MultiplayerModels::FRequestMultiplayerServerRequest::~FRequestMultiplayerServerRequest()
{

}

void PlayFab::MultiplayerModels::FRequestMultiplayerServerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId);

    if (InitialPlayers.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("InitialPlayers"));
        for (const FString& item : InitialPlayers)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    writer->WriteArrayStart(TEXT("PreferredRegions"));
    for (const AzureRegion& item : PreferredRegions)
        writeAzureRegionEnumJSON(item, writer);
    writer->WriteArrayEnd();


    if (SessionCookie.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SessionCookie")); writer->WriteValue(SessionCookie); }

    writer->WriteIdentifierPrefix(TEXT("SessionId")); writer->WriteValue(SessionId);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FRequestMultiplayerServerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    obj->TryGetStringArrayField(TEXT("InitialPlayers"), InitialPlayers);

    const TArray<TSharedPtr<FJsonValue>>&PreferredRegionsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("PreferredRegions"));
    for (int32 Idx = 0; Idx < PreferredRegionsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PreferredRegionsArray[Idx];
        PreferredRegions.Add(readAzureRegionFromValue(CurrentItem));
    }


    const TSharedPtr<FJsonValue> SessionCookieValue = obj->TryGetField(TEXT("SessionCookie"));
    if (SessionCookieValue.IsValid() && !SessionCookieValue->IsNull())
    {
        FString TmpValue;
        if (SessionCookieValue->TryGetString(TmpValue)) { SessionCookie = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SessionIdValue = obj->TryGetField(TEXT("SessionId"));
    if (SessionIdValue.IsValid() && !SessionIdValue->IsNull())
    {
        FString TmpValue;
        if (SessionIdValue->TryGetString(TmpValue)) { SessionId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FRequestMultiplayerServerResponse::~FRequestMultiplayerServerResponse()
{

}

void PlayFab::MultiplayerModels::FRequestMultiplayerServerResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (ConnectedPlayers.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("ConnectedPlayers"));
        for (const FConnectedPlayer& item : ConnectedPlayers)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (IPV4Address.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("IPV4Address")); writer->WriteValue(IPV4Address); }

    if (LastStateTransitionTime.notNull()) { writer->WriteIdentifierPrefix(TEXT("LastStateTransitionTime")); writeDatetime(LastStateTransitionTime, writer); }

    if (Ports.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Ports"));
        for (const FPort& item : Ports)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (Region.notNull()) { writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer); }

    if (ServerId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("ServerId")); writer->WriteValue(ServerId); }

    if (SessionId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("SessionId")); writer->WriteValue(SessionId); }

    if (State.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("State")); writer->WriteValue(State); }

    if (VmId.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("VmId")); writer->WriteValue(VmId); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FRequestMultiplayerServerResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&ConnectedPlayersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("ConnectedPlayers"));
    for (int32 Idx = 0; Idx < ConnectedPlayersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ConnectedPlayersArray[Idx];
        ConnectedPlayers.Add(FConnectedPlayer(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> IPV4AddressValue = obj->TryGetField(TEXT("IPV4Address"));
    if (IPV4AddressValue.IsValid() && !IPV4AddressValue->IsNull())
    {
        FString TmpValue;
        if (IPV4AddressValue->TryGetString(TmpValue)) { IPV4Address = TmpValue; }
    }

    const TSharedPtr<FJsonValue> LastStateTransitionTimeValue = obj->TryGetField(TEXT("LastStateTransitionTime"));
    if (LastStateTransitionTimeValue.IsValid())
        LastStateTransitionTime = readDatetime(LastStateTransitionTimeValue);


    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> ServerIdValue = obj->TryGetField(TEXT("ServerId"));
    if (ServerIdValue.IsValid() && !ServerIdValue->IsNull())
    {
        FString TmpValue;
        if (ServerIdValue->TryGetString(TmpValue)) { ServerId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SessionIdValue = obj->TryGetField(TEXT("SessionId"));
    if (SessionIdValue.IsValid() && !SessionIdValue->IsNull())
    {
        FString TmpValue;
        if (SessionIdValue->TryGetString(TmpValue)) { SessionId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StateValue = obj->TryGetField(TEXT("State"));
    if (StateValue.IsValid() && !StateValue->IsNull())
    {
        FString TmpValue;
        if (StateValue->TryGetString(TmpValue)) { State = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FRolloverContainerRegistryCredentialsRequest::~FRolloverContainerRegistryCredentialsRequest()
{

}

void PlayFab::MultiplayerModels::FRolloverContainerRegistryCredentialsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FRolloverContainerRegistryCredentialsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FRolloverContainerRegistryCredentialsResponse::~FRolloverContainerRegistryCredentialsResponse()
{

}

void PlayFab::MultiplayerModels::FRolloverContainerRegistryCredentialsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (DnsName.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("DnsName")); writer->WriteValue(DnsName); }

    if (Password.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("Password")); writer->WriteValue(Password); }

    if (Username.IsEmpty() == false) { writer->WriteIdentifierPrefix(TEXT("Username")); writer->WriteValue(Username); }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FRolloverContainerRegistryCredentialsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> DnsNameValue = obj->TryGetField(TEXT("DnsName"));
    if (DnsNameValue.IsValid() && !DnsNameValue->IsNull())
    {
        FString TmpValue;
        if (DnsNameValue->TryGetString(TmpValue)) { DnsName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PasswordValue = obj->TryGetField(TEXT("Password"));
    if (PasswordValue.IsValid() && !PasswordValue->IsNull())
    {
        FString TmpValue;
        if (PasswordValue->TryGetString(TmpValue)) { Password = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UsernameValue = obj->TryGetField(TEXT("Username"));
    if (UsernameValue.IsValid() && !UsernameValue->IsNull())
    {
        FString TmpValue;
        if (UsernameValue->TryGetString(TmpValue)) { Username = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FShutdownMultiplayerServerRequest::~FShutdownMultiplayerServerRequest()
{

}

void PlayFab::MultiplayerModels::FShutdownMultiplayerServerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId);

    writer->WriteIdentifierPrefix(TEXT("Region")); writeAzureRegionEnumJSON(Region, writer);

    writer->WriteIdentifierPrefix(TEXT("SessionId")); writer->WriteValue(SessionId);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FShutdownMultiplayerServerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    Region = readAzureRegionFromValue(obj->TryGetField(TEXT("Region")));

    const TSharedPtr<FJsonValue> SessionIdValue = obj->TryGetField(TEXT("SessionId"));
    if (SessionIdValue.IsValid() && !SessionIdValue->IsNull())
    {
        FString TmpValue;
        if (SessionIdValue->TryGetString(TmpValue)) { SessionId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FUpdateBuildRegionsRequest::~FUpdateBuildRegionsRequest()
{

}

void PlayFab::MultiplayerModels::FUpdateBuildRegionsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("BuildId")); writer->WriteValue(BuildId);

    writer->WriteArrayStart(TEXT("BuildRegions"));
    for (const FBuildRegionParams& item : BuildRegions)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FUpdateBuildRegionsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&BuildRegionsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("BuildRegions"));
    for (int32 Idx = 0; Idx < BuildRegionsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = BuildRegionsArray[Idx];
        BuildRegions.Add(FBuildRegionParams(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

PlayFab::MultiplayerModels::FUploadCertificateRequest::~FUploadCertificateRequest()
{

}

void PlayFab::MultiplayerModels::FUploadCertificateRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("GameCertificate")); GameCertificate.writeJSON(writer);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FUploadCertificateRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> GameCertificateValue = obj->TryGetField(TEXT("GameCertificate"));
    if (GameCertificateValue.IsValid() && !GameCertificateValue->IsNull())
    {
        GameCertificate = FCertificate(GameCertificateValue->AsObject());
    }

    return HasSucceeded;
}

